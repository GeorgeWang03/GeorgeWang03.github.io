<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeWang Blog</title>
    <description>iOS、创作与设计 | 王颖，iOS Engineer | 这里是王颖的个人博客，我们在这里分享技术，分享见闻，分享人生</description>
    <link>http://blog.oneinbest.com/</link>
    <atom:link href="http://blog.oneinbest.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 10 Oct 2016 18:34:46 +0800</pubDate>
    <lastBuildDate>Mon, 10 Oct 2016 18:34:46 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>创建自己的 Github 开源库并发布到 Cocoapods 插件库</title>
        <description>&lt;p&gt;&lt;strong&gt;前记：本文用于记录开源库的创建过程备忘以及初学者参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发者们平时在&lt;strong&gt;Github&lt;/strong&gt;查看各种功能的开源库时，是否想过开源库从何而来？开源库如何创建？使用&lt;strong&gt;Cocoapods&lt;/strong&gt;时的&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'someLibrary'&lt;/code&gt;从何而来？&lt;/p&gt;

&lt;p&gt;最近发布了个人第一个严格意义上的开源库&lt;a href=&quot;'https://github.com/GeorgeWang03/WYChart'&quot;&gt;&lt;strong&gt;WYChart&lt;/strong&gt;&lt;/a&gt;，便想着把这个过程记录下来，以便后来者参考。本文将主要从Cocoapods创建公开库来说明Github + Cocoapods开源库创建全过程。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods&quot;&gt;一、创建Cocoapods工程库&lt;/h2&gt;

&lt;h3 id=&quot;desktopiospods&quot;&gt;1. 在你存放开工程库的工程文件夹目录下（比如我的是~/Desktop/iOS/Pods)，执行下面命令：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pod lib create MyLibrary
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着会出现以下问题，即工程库为Objective-C还是Swift，&lt;code class=&quot;highlighter-rouge&quot;&gt;What language do you want to use?? [ Swift / ObjC ]&lt;/code&gt;，根据你的需要输入，比如输入&lt;code class=&quot;highlighter-rouge&quot;&gt;Objc&lt;/code&gt;，然后Enter；&lt;/p&gt;

&lt;p&gt;再接着是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Would you like to include a demo application with your library? [ Yes / No ]&lt;/code&gt;，也就是是否包含&lt;strong&gt;例子工程(demo)&lt;/strong&gt;，需要的话选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Yes&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;然后是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Which testing frameworks will you use? [ Specta / Kiwi / None ]&lt;/code&gt;，选择测试框架，不需要的话选&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;接着是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Would you like to do view based testing? [ Yes / No ]&lt;/code&gt;，是否要基于视图测试；&lt;/p&gt;

&lt;p&gt;最后是&lt;code class=&quot;highlighter-rouge&quot;&gt;What is your class prefix?&lt;/code&gt;输入工程的前缀，所有的文件都会加上这个前缀。&lt;/p&gt;

&lt;p&gt;成功之后会有以下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Ace! you're ready to go!
	We will start you off by opening your project in Xcode
	open 'WYAnimations/Example/WYAnimations.xcworkspace'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即工程库创建成功，🍺🍺🎆🎆🍻🍻&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2. 工程库目录简介&lt;/h3&gt;

&lt;p&gt;工程库创建完之后，Xcode界面会弹出:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-10-Github_Cocoapods/Xcode_Template.png&quot; alt=&quot;XcodeTemplate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上往下可以看到主要的文件夹有&lt;strong&gt;Podspec Metadata&lt;/strong&gt;，&lt;strong&gt;Example for yourLibrary&lt;/strong&gt;，&lt;strong&gt;Development Pods - YourLibrary&lt;/strong&gt;。
	&lt;strong&gt;Podspec Metadata&lt;/strong&gt;中分别有&lt;strong&gt;.podspec&lt;/strong&gt;、&lt;strong&gt;README.md&lt;/strong&gt;和&lt;strong&gt;LICENSE&lt;/strong&gt;，&lt;strong&gt;.podspec&lt;/strong&gt;为工程库的信息，详情格式google，&lt;strong&gt;README.md&lt;/strong&gt;中可以对工程库做介绍，cocoapods会默认帮你生成一个介绍的模版:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-10-Github_Cocoapods/README_DEFAULT.png&quot; alt=&quot;README&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，&lt;strong&gt;README&lt;/strong&gt;文件中常见的小图标，如&lt;img src=&quot;https://img.shields.io/cocoapods/l/WYAnimations.svg?style=flat&quot; alt=&quot;icon&quot; /&gt; 等，可以在&lt;a href=&quot;http://shields.io/&quot;&gt;这里&lt;/a&gt;找到并定制。
	&lt;strong&gt;LICENSE&lt;/strong&gt;默认是&lt;strong&gt;MIT&lt;/strong&gt;，你可以根据需要自行选择如Apache或 &lt;a href=&quot;http://choosealicense.com/&quot;&gt;其它的&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example for yourLibrary&lt;/strong&gt;便是存放Demo例子的文件夹，如同平时创建Xcode工程时一样。
	&lt;strong&gt;Development Pods - YourLibrary&lt;/strong&gt;，可以看到里面有&lt;strong&gt;ReplaceMe.m&lt;/strong&gt;文件，顾名思义，就是用你的组件库内容替换它，也即是工程库文件的存放地。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3. 开发&lt;/h3&gt;

&lt;p&gt;在了解并创建完上述的工程之后，就可以编写你的工程库以及demo例子，如果工程和例子已经写好，那么直接复制替换到文件夹中就可以进入下一步发包了。&lt;/p&gt;

&lt;h2 id=&quot;github&quot;&gt;二、加入版本控制并推到Github&lt;/h2&gt;

&lt;p&gt;在Github上创建一个工程库，并在刚刚创建的本地工程库目录中，执行下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init  //初始化git仓库
$ git add . //暂存所有修改
$ git commit -m &quot;first commit&quot;  //提交修改
$ git remote add origin git@github.com:YourUserName/	  YourRepository.git  //添加远程仓库
$ git push -u origin master  //把本地内容推到Github远程仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，你便可以随时将修改更新到Github仓库上。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods-1&quot;&gt;三、把版本的工程库发布到Cocoapods公开库或私有库&lt;/h2&gt;

&lt;p&gt;备注：这里主要介绍公开库，私有库👉&lt;a href=&quot;https://guides.cocoapods.org/making/private-cocoapods&quot;&gt;点击这里&lt;/a&gt;，公开库英文原版介绍👉&lt;a href=&quot;https://guides.cocoapods.org/making/getting-setup-with-trunk&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;pod&quot;&gt;1.创建pod帐号&lt;/h3&gt;

&lt;p&gt;如果你已经创建过，可以跳过这一步。&lt;/p&gt;

&lt;p&gt;在终端输入(pod帐号不需要密码，只是一个token存放在你的机器上)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pod trunk register 你的邮箱 '你的用户名' --description='关于你的机器的描述'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建完，或者创建过之后，执行下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pod trunk me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会出现如下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- Name:     GeorgeWang  //用户名
  		- Email:    georgewang003@gmail.com  //邮箱
  		- Since:    September 18th, 08:44  //时间
  		- Pods:	// 创建过的开源库
		- WYChart
  		- Sessions:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.发布开源库&lt;/h3&gt;

&lt;p&gt;⚠️ 需要注意的是，cocoapods对发布的开源库要求没有任何错误或警告信息，而且要有证书（这一点由于我们在上面的创建中已经生成证书所以不用担心）。&lt;/p&gt;

&lt;p&gt;确定你的工程没有问题，以及版本正确之后，你需要在你的项目目录中创建一个&lt;strong&gt;git分支&lt;/strong&gt;，标注版本号，如&lt;code class=&quot;highlighter-rouge&quot;&gt;0.1.0&lt;/code&gt;，这样才会被cocoapods接受。&lt;/p&gt;

&lt;p&gt;最后，在工程库目录执行下述命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pod trunk push [NAME.podspec]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果成功的话，工程库便发布到cocoapods上了。&lt;/p&gt;

&lt;p&gt;可以在其它工程里面的&lt;strong&gt;podfile&lt;/strong&gt;尝试加入&lt;code class=&quot;highlighter-rouge&quot;&gt;pod YourRepository&lt;/code&gt;，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;，如果成功，即工程库发布成功。🍻🍻🎆🎆&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记：发布流程至此结束，如果你对开源库有兴趣，行动吧，并推广你的开源库，让更多人知道你！&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 01:13:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/10/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Github-%E5%BC%80%E6%BA%90%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0-Cocoapods-%E6%8F%92%E4%BB%B6%E5%BA%93/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/10/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Github-%E5%BC%80%E6%BA%90%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0-Cocoapods-%E6%8F%92%E4%BB%B6%E5%BA%93/</guid>
        
        <category>Github</category>
        
        <category>Cocoapods</category>
        
        <category>OpenSource</category>
        
        
      </item>
    
      <item>
        <title>Github 的 ssh 秘钥配置 以及登录问题</title>
        <description>&lt;p&gt;最近在github上部署项目的时候遇到一个问题，将项目拷贝下来之后，修改完再度push上去，却收到 &lt;strong&gt;Permission to user/repo denied to other-user&lt;/strong&gt; 的错误，在github help搜索之后，其给出的答案如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	This error means the key you are pushing with is attached to an account which does not have access to the repository.
	To fix this, the owner of the repository (user) needs to add your account (other-user) as a collaborator on the repository or to a team that has write access to the repository.  大概意思就是所给出的秘钥无权利访问这个项目。需要让项目所有者将other-user加入到项目组。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;先说下最终的解决办法，其实就是以前登录过的账户保留在系统的钥匙串中，所以当前的用户是other-user，自然无权利访问。办法就是在系统钥匙串设置中将以前的邮箱关于github的钥匙串删除，回到终端重新push，输入账户和用户名，便可以。&lt;/p&gt;

&lt;p&gt;下面是分界线
***&lt;/p&gt;

&lt;p&gt;解决这个问题的时候，更重要的是一开始的误打误撞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.最开始&lt;/strong&gt; 以为是git的config问题，于是修改username,useremail等，下面是关于git config的一些设置方法&lt;/p&gt;

&lt;p&gt;config文件路径(mac os下) ： ~/.gitconfig&lt;/p&gt;

&lt;p&gt;config的设置分为几个等级，global，project，子级默认用上级的设置。&lt;/p&gt;

&lt;p&gt;命令行的设置法&lt;/p&gt;

&lt;p&gt;git config [–global] user.name yourUsername
git config [–global] user.email yourUsername&lt;/p&gt;

&lt;p&gt;在项目根目录下执行时，不加–global选项，为设置项目git配置。&lt;/p&gt;

&lt;p&gt;config的作用是，设置分支开发时的作者信息，暂时了解这点，其他的后续再研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.随后&lt;/strong&gt; 在stackoverflow和githelp上搜索，说是公钥的问题，于是研究了一下ssh key的配置&lt;/p&gt;

&lt;p&gt;github用rsa非对称秘钥来进行https的加密，用于客户端与github服务器进行通信时的认证，也就是常见的 git@github.com:user/rep 远程仓库通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于ssh key的部署&lt;/strong&gt;，👉 &lt;a href=&quot;&amp;quot;https://help.github.com/categories/ssh/&amp;quot;&quot;&gt;官方教程&lt;/a&gt; 
大概的步骤是&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.查看系统已经存在的rsa秘钥对&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ ls -al ~/.ssh  如果出现id_dsa与id_dsa.pub类似的私钥公钥秘钥对的话，就证明以前配置过，当然在这里是介绍怎么配置，所以继续往下看
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.新建秘钥对并添加到ssh代理&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;  然后设置秘钥的名字

	Enter a file in which to save the key (/Users/you/.ssh/id_rsa):  一般自己命名为 **id_rsa_somename**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下去的问题验证有兴趣的可以到githelp看，这里不做详解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Enter passphrase (empty for no passphrase): [Type a passphrase]
	Enter same passphrase again: [Type passphrase again]  直接按enter也可以
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.把秘钥对添加到代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先查看代理是否可用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ eval &quot;$(ssh-agent -s)&quot;  出现下面结果

	Agent pid 59566(或者其它id)  证明是有用的，然后

	$ ssh-add ~/.ssh/id_rsa  id_rsa应该是第2步时你秘钥的命名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.把秘钥添加到你的github&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复制秘钥信息到粘贴板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pbcopy &amp;lt; ~/.ssh/id_rsa.pub  选择github个人的 **setting-SSH and GPG keys-New SSH key or Add SSH key**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入一个秘钥名字，然后command+v粘贴秘钥内容，最后点击&lt;strong&gt;Add SSH key&lt;/strong&gt;确认。&lt;/p&gt;

&lt;p&gt;5.检测秘钥对是否能链接成功&lt;/p&gt;

&lt;p&gt;终端输入 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	ssh -T git@github.com  如果出现：

	Hi username! You've successfully authenticated, but GitHub does not provide shell access.  则验证成功，可以正常使用了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实如果没配置ssh key的话，提示的错误信息应该是 &lt;strong&gt;Permission to user/repo denied to (other-)user/other-repo&lt;/strong&gt; ，所以遇到这个问题时也可以借鉴一下。&lt;/p&gt;

&lt;p&gt;如果有其它问题，请到githelp寻求帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt; 两种就是一开始误打误撞去探究的结果，虽说没有解决问题，但是也学如何配置git的秘钥等内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总而言之&lt;/strong&gt;，github的账户切换时，要注意对配置信息和钥匙串的更换，否则会出现Permission … denied to … 的错误。&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Sep 2016 23:22:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/09/22/Github-%E7%9A%84-ssh-%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/09/22/Github-%E7%9A%84-ssh-%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</guid>
        
        <category>Git</category>
        
        <category>ssh</category>
        
        
      </item>
    
      <item>
        <title>关于我的博客说明</title>
        <description>&lt;p&gt;这是我的新博客，基于gitpage和jekyll搭建。&lt;/p&gt;

&lt;p&gt;你可能会看到有些文章比我博客项目时间还早，这是因为很多文章是从以前的&lt;a href=&quot;&amp;quot;www.oneinbset.com&amp;quot;&quot;&gt;博客&lt;/a&gt;迁过来的，是以前写的，不舍得放弃，所以迁过来了。&lt;/p&gt;

&lt;p&gt;我比较喜欢折腾，从一开始在csdn写博客，发现不尽我意，又自己买了一个主机和域名，使用wp搭建一个博客，现在由于wp比较笨重，加上所购买的主机空间有限，果断抛弃之，使用更加轻量级的jekyll和空间无限的gitpage。&lt;/p&gt;

&lt;p&gt;最后，欢迎来到我的博客，我会尽我所能，把我觉得有意义有价值的事情记录下来，您的支持是我的动力，谢谢！🍻🍻&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 07:39:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/09/22/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/09/22/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</guid>
        
        <category>博客说明</category>
        
        
      </item>
    
      <item>
        <title>iOS中的KVO机制剖析</title>
        <description>&lt;p&gt;KVO即 key value observing键值对观察，是objc中的一种机制。
KVO以KVC(key value coding)为基础，通过向对象的某个键值添加观察者，当对象键所对应的值发生变化时，通知观察者，执行相关的回调方法。&lt;/p&gt;

&lt;p&gt;以下描述分为KVO的使用，OBJC实现KVO机制的剖析，KVO的DIY，fb的KVO开源库介绍，四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	KVO的操作回调是在同一个线程中进行的，和NOTIFICATION一样
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;kvo&quot;&gt;1. KVO的使用&lt;/h2&gt;
&lt;p&gt;objc中给对象键值添加观察者，通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[obj addObserver:forKeyPath:option:context:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回调函数： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;observeValueForKeyPath:ofObject:change:context:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除通知：(这是一定要的，不然会导致crash)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;removeObserver:forKeyPath:
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objckvo&quot;&gt;2. OBJC实现KVO机制的剖析&lt;/h2&gt;
&lt;p&gt;先贴上几个解析来源：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;a href=&quot;&amp;quot;https://github.com/ChenYilong/iOSInterviewQuestions&amp;quot;&quot;&gt;《招聘一个靠谱的iOS》面试题&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;a href=&quot;&amp;quot;https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html&amp;quot;&quot;&gt;https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;objc通过什么来实现对键值添加观察者并发送通知呢？&lt;/p&gt;

&lt;p&gt;objc基于runtime,以setter方法为入口，实现这一机制。
首先需要知道的是，objc的对象实例isa指针，内存布局，Class结构体表示类。&lt;/p&gt;

&lt;p&gt;当向对象添加键值观察者时，objc通过runtime动态生成对象所属的类的子类，重写setter，并将对象的isa指针指向新类，在此过程中还重写了子类的class方法，向开发者隐藏新建子类 (也就是所谓的isa混写(isa-swizzling))。&lt;/p&gt;

&lt;p&gt;在新的类的setter中，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[super setObject:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在前后执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self willChangeValueForKey:]与[self didChangeValueForKey:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在后者执行时调用观察者的回调函数，所以在观察者dealloc时必须注销所设置的观察，否则会发送消息给dealloc对象，造成crash。&lt;/p&gt;

&lt;p&gt;##3. KVO的DIY
照例贴上手动实现KVO的方法链接：&lt;a href=&quot;&amp;quot;http://tech.glowing.com/cn/implement-kvo/&amp;quot;&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过上面的剖析，我们知道了KVO的实现原理&lt;/p&gt;

&lt;p&gt;如果要手动实现，那有两个过程必须实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.添加观察者接口及过程
2.键值改变时的通知过程实现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;1.添加观察者接口及过程&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1 检查对象的类有没有相应setter方法，如果没有抛出异常；
	检查对象 isa 指向的类是不是一个有kPGKVOClassPrefix前缀的KVO类，如果不是需要创建新子类，并把isa指针指向新类，实现class方法

1.2 检查有没有KVO的setter方法，没有的话构建新类的setter方法

1.3 把观察者添加到观察者列表，使用***关联对象(objc_setAssociationObj)*** 绑定列表
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.键值改变时的通知过程实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.1 通过runtime动态执行父类也就是原来的类的setter方法

2.2 取出有关keyPath的观察者，并逐一调用回调函数block
  ##4.KVOController
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;👉 &lt;a ref=&quot;&quot;&gt;FaceBook的KVOController链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;KVOController是Facebook开源的一个KVO库，其可以聚合KVO操作，使用block执行观察操作，好处是可以不用自己去remove观察者，防止因为忘记remove造成crash，以下是其用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// create KVO controller with observer
FBKVOController *KVOController = [FBKVOController controllerWithObserver:self];
self.KVOController = KVOController;

// observe clock date property
[self.KVOController observe:clock keyPath:@&quot;date&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(ClockView *clockView, Clock *clock, NSDictionary *change) {

  // update clock view with new value
  clockView.date = change[NSKeyValueChangeNewKey];
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;KVO&lt;/strong&gt; 是objc一项重要的特性和设计模式，也是GOF观察者模式的实现。开发中经常用于观察数据层(data)变化而对视图层(view)作出相应的改变，也是一种响应方式。由于其需要手动移动观察，否则会导致crash，所以使用时需要小心。Facebook的KVOController对objc的KVO进行封装，使用block模式，让开发者更省心。KVO在objc的底层实现是isa混编，生成子类并重写setter，然后通知观察中。手动实现KVO需要对类做是否KVO子类的判断，从而决定是否生成子类。总而言之，KVO是objc中一个比较重要的语言特性，使用好它，能为你带来不小的好处。&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 07:39:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2015/12/23/iOS%E4%B8%AD%E7%9A%84KVO%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2015/12/23/iOS%E4%B8%AD%E7%9A%84KVO%E6%9C%BA%E5%88%B6/</guid>
        
        <category>iOS</category>
        
        <category>KVO</category>
        
        
      </item>
    
      <item>
        <title>Objective-C 内存布局与对象生成</title>
        <description>&lt;p&gt;一直以来零碎的，连续的看过一些关于OC的内存布局及对象生成方案的文章，没对这方面的知识进行一个总结是心头大患 😔😔。&lt;/p&gt;

&lt;p&gt;接下来在这篇文章中，我将会介绍这方面的相关知识，只要内容有：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Object-C的类对象内存布局&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.Object-C对象如何生成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;废话不多说，我们开始吧！🎁🍺👇👇&lt;/p&gt;

&lt;h2 id=&quot;object-c&quot;&gt;一、Object-C的类对象内存布局&lt;/h2&gt;
&lt;p&gt; 	我们知道Object-C是又前端编译器clang转换为C++/C进而编译为机器码的；我们还知道Object-C中的类是单继承的；
	对于Object-C的一个类对象实例，或许你曾听说它有一个isa指针,这个isa有什么作用呢？
	通过下面一张图可能你会发现一些端倪 
	&lt;img src=&quot;/img/post_img/2015-11-17-objectivec/oc_memory_struct.jpg&quot; alt=&quot;oc_memory_struct&quot; /&gt;  	是的，类对象中除了isa指针还有superclass指针。
 isa顾名思义，is a class。。。来指明这是一个什么类的对象。
	根据上图，isa指针指向一个metaClass元类对象，这个对象是全局的，而且只有一个，metaClass存放类的静态变量和类方法，NSObject类对象的isa指向自身，而superClass指针则指向父类对象，NSObject类对象的superClass指针指向nil。&lt;/p&gt;

&lt;p&gt;当然，类对象和元类对象都拥有这两个指针，只是有所不同，从图中我们同样可以看到metaClass的isa指针指向的是NSObject元类对象，NSObject元类对象的isa指针则是指向自身；而其superClass则都指向父类的元类对象。&lt;/p&gt;

&lt;p&gt;当然，类中的信息不仅仅有isa和superClass指针，从runtime文件中我们可以找到Class的结构定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct objc_class {
Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中包括&lt;strong&gt;ivars&lt;/strong&gt;、&lt;strong&gt;methodLists&lt;/strong&gt;和&lt;strong&gt;protocol&lt;/strong&gt;等重要的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_ivar_list&lt;/code&gt;是类对象所持有的对象实例，最常见的就是平时声明&lt;strong&gt;@property&lt;/strong&gt;时，用下划线表示的_someProperty变量；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_method_list&lt;/code&gt;是存放所有实例方法的列表，调用实例对象的方法时，会在此列表中遍历寻找对应的函数入口；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_protocol_list&lt;/code&gt;存放该类所遵循的协议；&lt;/li&gt;
  &lt;li&gt;值得注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_cache&lt;/code&gt;，这是什么东西？其实这是objc对方法访问做优化的一个缓存，由于方法列表有可能很大，如果每次都在列表里面遍历，那效率自然就下降，特别是对于一些经常访问的方法，如tableView的&lt;code class=&quot;highlighter-rouge&quot;&gt;tableView:cellForRowsAtIndexPath:&lt;/code&gt;，高频率的访问带来的高频率遍历会耗费很多时间，而有了cache之后，在其中访问高频方法，速度会提升不少。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;细心的读者会主要到图中还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_object&lt;/code&gt;，这是一个什么东西呢？  这其实就是我们平常所声明的实例对象，其通过clang转换为以下结构：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  struct objc_object {
  	Class isa;
  };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其中只有一个isa类对象，就是指向对应的类对象内存地址，如上图所示。 既然提到oc的对象指针，那么我们自然会想到oc中的特殊指针id。 在runtime文件中我们同样可以看到id的定义：&lt;/p&gt;

    &lt;p&gt;typedef struct objc_object *id;
 这也就不难理解为什么id指针不用 * 而其他的要有 * 。
 所以我们平常所提到的&lt;strong&gt;isa&lt;/strong&gt;有三种含义，第一是&lt;strong&gt;实例对象的结构体中的isa&lt;/strong&gt;对象，第二是&lt;strong&gt;类中的isa&lt;/strong&gt;，其指向&lt;strong&gt;metaClass&lt;/strong&gt;类对象，第三是&lt;strong&gt;元类中的isa&lt;/strong&gt;,其指向NSObject元类对象。
  平常我们调用对象的变量，指针都通过第一类isa也就是实例对象中的isa去寻找相关的内容。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;object-c-1&quot;&gt;二、Object-C对象如何生成&lt;/h2&gt;
&lt;p&gt;有了上面的描述之后，相信大家对于objc中的类已经有一定的理解，甚至对其如何生成有一定的概念了。&lt;/p&gt;

&lt;p&gt;那么，一个Object-C对象在运行时如何被如何创建呢？&lt;/p&gt;

&lt;p&gt;可以这么说，当我们&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc/init&lt;/code&gt;一个对象时，runtime会创建oc独有的objc_object结构体对象，在创建结构体时会创建其中的isa，然后根据类的相关继承定义，由上往下，由父类往子类去创建相关的类对象，并把其中每个类对象的isa指向全局的meta元类对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc/init&lt;/code&gt;如何执行？&lt;/p&gt;

&lt;p&gt;一般我们在oc中创建一个对象的方式是&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Object alloc] init]&lt;/code&gt;,这相比起C++的new方法，多了一层函数调用。alloc会先在内存中申请对象的内存空间,init作为构造函数把相关的初始化值赋给对象，对于如NSString,NSDictionary等Foundation框架的对象，由于未能确定其数据长度，在alloc时会先指向一个placeHolder对象，当init的时候再申请相关的内存地址，其中的原因关乎内存字节对齐，由于这部分超出了本文的讨论范围，所以不讲，详情移步google。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;Objective-C基于C，其类对象在C语言层面是结构体，由clang转换而成，要探究Objective-C的内存布局，必须从C语言的结构体层面入手。经过分析，我们了解到其大体结构，主要的内容由isa、ivar、method_list等，并且由isa和superclass串联起整个布局。Objective-C对象生成时，实质是生成C的结构体实例，并对串联的isa、superclass指针做初始化，起到布局作用，在oc语言层面的alloc/init使得对象的内存分配和初始化分开，过程更加明确。总而言之，了解和掌握Objective-C的内存布局及对象的创建过程，有助于平时开发和调试，也是提升开发能力的一个要求。&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Nov 2015 17:04:18 +0800</pubDate>
        <link>http://blog.oneinbest.com/2015/11/17/Objective-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2015/11/17/Objective-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>内存</category>
        
        
      </item>
    
  </channel>
</rss>
