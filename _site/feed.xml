<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeWang Blog</title>
    <description>iOS、创作与设计 | 王颖，iOS Engineer | 这里是王颖的个人博客，我们在这里分享技术，分享见闻，分享人生</description>
    <link>http://blog.oneinbest.com/</link>
    <atom:link href="http://blog.oneinbest.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 07 Nov 2016 22:09:33 +0800</pubDate>
    <lastBuildDate>Mon, 07 Nov 2016 22:09:33 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>WYChart介绍系列（五）交互：线型图触碰点以及缩放的实现</title>
        <description>&lt;p&gt;前面三张分别介绍了&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;中线型图的总体规划、绘制、动画的实现，相信看完的读者对于如何实现一个带效果的线型图有一个整体的概念了，那么，再加上接下来要介绍的这一点，那么线型图的实现就完整了，那就是交互的实现。&lt;/p&gt;

&lt;p&gt;线型图中主要的交互有两种，第一是曲线上点的触碰获取，第二是缩放。（其实还有一点，就是可滑动，由于相对简单，不展开）&lt;/p&gt;

&lt;p&gt;本文将从以下两点介绍：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可滑动触碰点实现&lt;/li&gt;
  &lt;li&gt;缩放实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一点比较复杂，第二点相对简单，话不多说，现在开始吧。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;可滑动触碰点的实现&lt;/h2&gt;

&lt;p&gt;这一点是基于读者对贝塞尔曲线有一定了解的基础上做介绍的，如果还不了解，参考前面系列文章第三篇。 👉 &lt;a href=&quot;&quot;&gt;前往&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由前面文章的介绍，我们可知&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;中线型图有三种线型，直线、波浪曲线和尖峰曲线。在触碰点实现中，我们把他们分成两个类别，第一个是直线，第二个是曲线，即波浪曲线和尖峰曲线。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;首先是直线&lt;/h4&gt;

&lt;p&gt;获取直线上的点，由于触碰点的x代表直线上的x，但是y并不代表真实的y，所以这里第一步就是获取y（出发点），回想我们初高中学到的根据x求y值，那就是一次函数方程式了，可以根据斜率很快地得出某段直线x对应的y值。在&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;的实现中，我们把曲线分成了n段进行绘制，看过源码的读者应该知道代码中是用&lt;code class=&quot;highlighter-rouge&quot;&gt;WYLineChartPathSegment&lt;/code&gt;表示曲线段的，其中主要属性如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WYLineChartPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//起始点
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WYLineChartPoint&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//结束点
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WYLineChartPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;controlPoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//控制点
&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficientA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//系数a
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficientB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//系数b
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coefficientC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//系数c
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;咋一看是表示贝塞尔曲线和一元二次方程式的，但是，只要系数a=0，那么二次方程式不就是一次方程式吗，因此，线段的方程式计算代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	 segment.coefficientA = 0;
	 segment.coefficientB = (endPoint.y - startPoint.y) / (endPoint.x - startPoint.x); //斜率计算
	 segment.coefficientC = startPoint.y - segment.coefficientB * startPoint.x; //常数计算
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;触碰点对应的y值计算方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- (CGFloat)yValueCalculteFromQuadraticFormulaForPoint:(CGPoint)point {

		CGFloat x = point.x;
		return _coefficientA * powf(x, 2) + _coefficientB * x + _coefficientC;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;_coefficientA = 0&lt;/code&gt;，故这里相当于 ` _coefficientB * x + _coefficientC&lt;code class=&quot;highlighter-rouge&quot;&gt; 即 &lt;/code&gt;y=bx+c`一次方程形式。&lt;/p&gt;

&lt;p&gt;以上便是直线的y值获取方式。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;其次是曲线&lt;/h4&gt;

&lt;p&gt;曲线上的x对应y值的获取，和直线一样，通过方程式获取，这时候你可能会想，那就通过二次方程式 &lt;code class=&quot;highlighter-rouge&quot;&gt;y=ax^2+bx+c&lt;/code&gt; 代入照搬吧！&lt;/p&gt;

&lt;p&gt;那么问题来了，二次方程式的系数如何获取？贝塞尔曲线是否就是二次方程式绘制出来的？&lt;/p&gt;

&lt;p&gt;对于后一个问题，答案是否定的。而要解第一个问题，就先要解决第二个问题。&lt;/p&gt;

&lt;p&gt;所有贝塞尔曲线（二次，这里不讨论三次贝塞尔）是抛物线，但是抛物线不一定可以用二次方程式表示。故，要获取二次方程式的系数，就要确定我们所绘制的二次贝塞尔曲线可以用二次方程式表示，相关推理参照&lt;a href=&quot;http://math.stackexchange.com/questions/1257576/convert-quadratic-bezier-curve-to-parabola&quot;&gt;歪果仁的回答&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;也就是，二次曲线的三个控制点要满足以下关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/bezier_cur_infer_1.png&quot; alt=&quot;bezier_cur_infer_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即控制点在&lt;strong&gt;x轴上&lt;/strong&gt;必需是&lt;strong&gt;起始点&lt;/strong&gt;和&lt;strong&gt;终止点&lt;/strong&gt;的中点，&lt;code class=&quot;highlighter-rouge&quot;&gt;x2 = (x1 + x3)/2&lt;/code&gt;（为什么是这样，唯一知道的就是控制点x一定要是起始点和终止点之间，这样才不会导致一个x对应两个y值，但为什么是&lt;code class=&quot;highlighter-rouge&quot;&gt;x2 = (x1 + x2)/2&lt;/code&gt;，这个还需要推论，有读者知道，望指教），幸运的是，&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;中的曲线符合这个关系，看过前面文章的读者应该记得，绘制平滑曲线时，我们便是取中点绘制曲线的。&lt;/p&gt;

&lt;p&gt;由以下贝塞尔曲线绘制图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/two_times_bezier.gif&quot; alt=&quot;two_times_bezier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再结合上述歪果仁的回答，我们知道，起始点的斜率为起点和控制点连线的斜率，终点斜率为终点与控制点连线的斜率（这个结论其实还不严谨，需要一个证明过程，如果有读者知道，望指教)，于是有以下斜率关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/bezier_cur_infer_2.png&quot; alt=&quot;bezier_cur_infer_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再由以上公式做推导，可以得到以下关系，进而求出系数a、b：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/bezier_cur_infer_3.png&quot; alt=&quot;bezier_cur_infer_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了系数a、b，那么参数c就可以很容易求出了。于是，触碰点的曲线y值就可以求出，带入二次方程，代码实现与上文直线求值一致。
因此，根据触碰点的变化，我们就可以求出曲线上对应的点了。&lt;/p&gt;

&lt;p&gt;上述直线与曲线y值求出，但还有一点没提到，就是：&lt;/p&gt;
&lt;h4 id=&quot;section-3&quot;&gt;具体线段的寻找&lt;/h4&gt;

&lt;p&gt;我们的线由很多个线段组成，在求出具体的值之前，还需要寻找具体的线段。
在代码中，我们定义了一个数组用于存放所有&lt;code class=&quot;highlighter-rouge&quot;&gt;WYLineChartPathSegment&lt;/code&gt;线段，在获取触碰点时，遍历线段集合（后续优化可以采用二分查找提高效率），找到其中满足&lt;code class=&quot;highlighter-rouge&quot;&gt;x&amp;lt;endPoint.x &amp;amp;&amp;amp; x&amp;gt;startPoint.x&lt;/code&gt;的线段，然后带入线段所属方程式，即可得到指定的点；如果线段不存在，意味着超出了线的范围。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;最后&lt;/h4&gt;

&lt;p&gt;我们需要定义一个长按手势，用于启动并移动，然后把对应视图中的点转换成线段上的点，最后更新触碰点的位置，需要时做动画。&lt;/p&gt;

&lt;p&gt;以上便是触碰点的实现，最初需要理解掌握贝塞尔曲线的概念及部分原理，然后是点转换的分析，接着是直线与曲线的方程式，再者是二次贝塞尔曲线与二次方程式的关系，最后是点的转换及绘制，分而治之，逐个击破，看似有点难度的触碰点实现也就很简单了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;缩放的实现&lt;/h2&gt;

&lt;p&gt;在&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;线型图中，我们实现了一个捏合手势（&lt;code class=&quot;highlighter-rouge&quot;&gt;UIPinchGestureRecognizer&lt;/code&gt;）做图形缩放的交互功能。原理其实挺简单，就是利用捏合手势获取到的缩放系数scale，对线图做水平缩放，缩放时采用CGAffineTransform来实现，并做透明度随缩放系数scale的变化，实现过渡效果，让交互更加自然。实现代码大概如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- (void)handlePinchGesture:(UIPinchGestureRecognizer *)recognize {
    	if (!_pinchable) return;
		[self transformComponentsWithPinchScale:recognize.scale];
		...
		// 根据手势状态的变化通知代理
		...
	}
	
	- (void)transformComponentsWithPinchScale:(CGFloat)scale {

		CGAffineTransform transform = CGAffineTransformIdentity;
		transform = CGAffineTransformScale(transform, scale, 1.0);

		CGFloat alpha = scale * 0.3; // 转换为透明度变化系数

		_lineGraph.transform = transform; // 线图前景缩放
		_lineGraph.alpha = alpha; 		    // 线图前景透明度变化

		_verticalReferenceLineGraph.transform = transform; // 垂直方向参考线视图缩放
		_verticalReferenceLineGraph.alpha = alpha; // 垂直方向参考线视图透明度变化

		_xAxisView.transform = transform; // x轴前景缩放
		_xAxisView.alpha = alpha;

		_yAxisView.alpha = alpha;
		_horizontalReferenceLineGraph.alpha = alpha;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;CGAffineTransform &lt;/code&gt; 相信大多数人都有一定的使用经验，简单地说就是一个平面图形变化运算，经常在交互及动画中用到，相关的有CATransform3D可做3D变化运算，在这里不多赘述，详情可参照官方文档及&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;源码。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;至此，关于&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;中线型图的交互介绍完毕。 🍻🍻
一个好的图形，不仅仅是造型漂亮精美，还需要动画及交互功能的搭配，才更有生机活力，更能让用户青睐。
&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;的线型图，是集多种动画、交互功能与一体，并且有着不差的UI外观及自由定制的功能。
至今，通过4篇文章的介绍，&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;线型图的介绍也全部完成，其中包括设计、实现、及一些cocoa touch类的介绍，既是我自己的一个开发笔记，也是与开发者们交流学习的文章，希望各位能提出宝贵的意见，多多指教。如果觉得我的&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03&quot;&gt;github开源项目&lt;/a&gt;&lt;/strong&gt;还不错的话，希望能得到你的星星✨点赞，谢谢。&lt;/p&gt;

&lt;p&gt;开发&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;并写了这好几篇文章，用了不少时间，计划中接下来是&lt;strong&gt;继续WYChart的后续开发&lt;/strong&gt;以及&lt;strong&gt;关于WYChart扇形图的实现的介绍文章的撰写&lt;/strong&gt;，不过由于工作的原因，有时候没办法挤出太多时间去做，当然我会尽我所能去完成，有什么不周到的地方请见谅。希望大家都为开源做贡献！&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Nov 2016 06:00:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/11/07/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%BA%94-%E4%BA%A4%E4%BA%92-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E8%A7%A6%E7%A2%B0%E7%82%B9%E4%BB%A5%E5%8F%8A%E7%BC%A9%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/11/07/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%BA%94-%E4%BA%A4%E4%BA%92-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E8%A7%A6%E7%A2%B0%E7%82%B9%E4%BB%A5%E5%8F%8A%E7%BC%A9%E6%94%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        
        <category>WYChart</category>
        
        <category>开源</category>
        
        <category>绘制</category>
        
        <category>交互</category>
        
        
      </item>
    
      <item>
        <title>WYChart介绍系列（四）线型图动画的实现</title>
        <description>&lt;p&gt;在前面的文章中有提到WYChart中线型图使用的是CoreAnimation框架，动画的制作也是使用里面一系列的效果。&lt;/p&gt;

&lt;p&gt;本文将分为下面几个部分做讲解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CoreAnimation的动画类CABasicAnimation及其子类&lt;/li&gt;
  &lt;li&gt;WYChart中线型图采用的动画类型&lt;/li&gt;
  &lt;li&gt;CADisplayLink+UIViewAnimation+CALayer的动画模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，开始吧 👇👇&lt;/p&gt;

&lt;h3 id=&quot;coreanimationcabasicanimation&quot;&gt;CoreAnimation的动画类CABasicAnimation及相关类&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;官方文档&lt;/a&gt;对CABasicAnimation的介绍是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation provides basic, single-keyframe animation capabilities for a layer property. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是，CABasicAnimation为Layer的属性提供基础，简单的关键帧动画。至于哪些属性能做动画，在各个Layer的头文件中有声明，如果是&lt;code class=&quot;highlighter-rouge&quot;&gt;animatable&lt;/code&gt;的，就是可以做动画的。&lt;/p&gt;

&lt;p&gt;CABasicAnimation有几个核心的属性：duration,fromValue,toValue以及keyPath，后者是通过工厂方法&lt;code class=&quot;highlighter-rouge&quot;&gt;animationWithKeyPath:&lt;/code&gt;初始化，也是用于动画的属性。前三个属性，duration用于定义动画的时长，fromValue和toValue分别是属性开始的值和结束的值，它们都只接受对象类型的变量，也就是如果是数值类型，需要先转化为NSNumber对象类型。比如，现在对一个图层做由透明到不透明的动画，应该这样做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation  *animation = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];
animation.duration = 1.0;
animation.fromValue = @(0.0);
animation.toValue = @(1.0);
[layer addAnimation:animation forKey:@&quot;opacity&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;CAAnimation.h&lt;/code&gt;头文件中，可以看到&lt;strong&gt;CABasicAnimation&lt;/strong&gt;是继承自&lt;strong&gt;CAPropertyAnimation&lt;/strong&gt;，后者是继承自&lt;strong&gt;CAAnimation&lt;/strong&gt;，关于&lt;strong&gt;CAPropertyAnimation&lt;/strong&gt;和&lt;strong&gt;CAAnimation&lt;/strong&gt;这里不展开介绍，有兴趣的自行Google。
重点在于，从头文件中我们可以看到除了&lt;strong&gt;CABasicAnimation&lt;/strong&gt;，还有&lt;strong&gt;CASpringAnimation&lt;/strong&gt;、&lt;strong&gt;CAKeyframeAnimation&lt;/strong&gt;以及&lt;strong&gt;CATransition&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CASpringAnimation&lt;/strong&gt;继承自CABasicAnimation，用于实现弹簧动画；它有几个属性用于设置弹簧的效果，比如用于设置重量的&lt;code class=&quot;highlighter-rouge&quot;&gt;mass&lt;/code&gt;，越大弹簧的压缩越严重；又如用于设置劲度系数的&lt;code class=&quot;highlighter-rouge&quot;&gt;stiffness&lt;/code&gt;，系数越大，动画开始时产品的力气越大，速度越快；还有阻尼系数&lt;code class=&quot;highlighter-rouge&quot;&gt;damping&lt;/code&gt;，越大弹簧动画停止越快；最后是初始速度&lt;code class=&quot;highlighter-rouge&quot;&gt;initialVelocity&lt;/code&gt;，表示一开始的速度。值得注意的是，有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;settlingDuration&lt;/code&gt;，用于估算动画的时间。为什么需要这个估算时间，因为如果将前面提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;duration&lt;/code&gt;属性设置小于这个估算时间，那动画会在弹簧停止之前便结束，这样看起来很奇怪，因此需要这个估算时间。不过，实践证明，这个估算时间也不怎么靠谱，所以，实际操作时还是要自己调试着。&lt;/p&gt;

&lt;p&gt;CAKeyframeAnimation继承自CAPropertyAnimation，用于关键帧动画；他有一个必选属性&lt;code class=&quot;highlighter-rouge&quot;&gt;values&lt;/code&gt;，表示&lt;code class=&quot;highlighter-rouge&quot;&gt;keypath&lt;/code&gt;的变化过程；此外，有一些可选的属性。&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;可选属性，一般用于轨迹动画，如旋转、抛物线等运动，当它不为空时，&lt;code class=&quot;highlighter-rouge&quot;&gt;values&lt;/code&gt;属性被覆盖；&lt;code class=&quot;highlighter-rouge&quot;&gt;keyTimes&lt;/code&gt;属性声明在&lt;code class=&quot;highlighter-rouge&quot;&gt;values&lt;/code&gt;中的值在哪个时间起作用；还有诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;timingFunctions&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;calculationMode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;rotationMode&lt;/code&gt;等属性，限于篇幅，这里不展开细讲。在后面的博文中，会开一篇细讲这几个动画。&lt;/p&gt;

&lt;p&gt;CATransition继承自CAAnimation，用于自定义页面跳转。在WYChart中我们不会用到，故也不展开讲，只是说明在CAAnimation族中有这个类。&lt;/p&gt;

&lt;p&gt;以上是CoreAnimation的动画类CABasicAnimation及相关类的介绍，应该说CABasicAnimation是基础，也是用得最多的，CASpringAnimation和CAKeyframeAnimation可以做出一些比较特别的动画。&lt;/p&gt;

&lt;h3 id=&quot;wychart&quot;&gt;WYChart中线型图采用的动画类型&lt;/h3&gt;

&lt;p&gt;在WYChart的线型图中，目前一共有五种动画，分别如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kWYLineChartAnimationDrawing // 绘制动画
kWYLineChartAnimationAlpha   // 透明度动画
kWYLineChartAnimationWidth   // 宽度渐变动画
kWYLineChartAnimationRise    // 上升动画
kWYLineChartAnimationSpring  // 弹簧动画
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前四个动画都相对比较简单，只要使用&lt;strong&gt;CABasicAnimation&lt;/strong&gt;就可以实现。例如绘制动画，实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation  *animation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];
animation.duration = _animationDuration;
animation.fromValue = @(0.0);
animation.toValue = @(1.0);
[lineLayer addAnimation:animation forKey:@&quot;strokeEnd&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;strokeEnd&lt;/code&gt;属性做绘制动画，效果如下：
&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/LineAnimation_Drawing.gif&quot; alt=&quot;Animation_Drawing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过这四个动画里面，&lt;code class=&quot;highlighter-rouge&quot;&gt;kWYLineChartAnimationRise&lt;/code&gt;还要对&lt;strong&gt;path&lt;/strong&gt;做一下处理。我们要实现线条由下往上升，于是需要两个预先定义好的&lt;strong&gt;path&lt;/strong&gt;，一个是最终状态，也就是最初构建的那个，另一个是初始状态，其每个点的Y值都比初始的值小7个单位的距离在代码中我们这样实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[linePath addQuadCurveToPoint:pathSegment.endPoint.point controlPoint:pathSegment.controlPoint.point];
[linePathLower addQuadCurveToPoint:[self pointBelowPoint:pathSegment.endPoint.point forDistance:DEFAULT_RISE_HEIGHT] controlPoint:[self pointBelowPoint:pathSegment.controlPoint.point forDistance:DEFAULT_RISE_HEIGHT]];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;linePath&lt;/code&gt;是最终状态，&lt;code class=&quot;highlighter-rouge&quot;&gt;linePathLower&lt;/code&gt;为初始状态，&lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULT_RISE_HEIGHT &lt;/code&gt;为上升高度。&lt;/p&gt;

&lt;p&gt;以上都是&lt;strong&gt;CABasicAnimation&lt;/strong&gt;的简单应用，真正重要的是接下来要讲的 👇👇&lt;/p&gt;

&lt;h3 id=&quot;cadisplaylinkuiviewanimationcalayer&quot;&gt;CADisplayLink+UIViewAnimation+CALayer的动画模式&lt;/h3&gt;

&lt;p&gt;在上文中还少了&lt;code class=&quot;highlighter-rouge&quot;&gt;kWYLineChartAnimationSpring&lt;/code&gt;动画没讲，因为涉及到的内容比较复杂，在这里细讲。&lt;/p&gt;

&lt;p&gt;我们要实现的效果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/LineAnimation_Spring.gif&quot; alt=&quot;Animation_Drawing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可能会想到使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CASpringAnimation&lt;/code&gt;结合&lt;code class=&quot;highlighter-rouge&quot;&gt;path&lt;/code&gt;属性来实现，没错，最初我也是采用这种做法，但不幸的是，其实际效果和我们的想去甚远，甚至扭曲严重。因此这种做法行不通，那是否还有其他途径？ 必需的！😜&lt;/p&gt;

&lt;p&gt;那就是CADisplayLink+UIViewAnimation+CALayer的动画模式，下面我们先对这几个概念做个介绍。&lt;/p&gt;

&lt;h4 id=&quot;cadisplaylink&quot;&gt;CADisplayLink&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore/cadisplaylink&quot;&gt;官方文档&lt;/a&gt;对&lt;strong&gt;CADisplayLink&lt;/strong&gt;的介绍如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是&lt;strong&gt;CADisplayLink可以让你的绘制和屏幕刷新频率同步&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;用法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CADisplayLink  *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleScreenUpdate)];
[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样子，假如屏幕的刷新频率是60pf/s，那么每秒&lt;code class=&quot;highlighter-rouge&quot;&gt;handleScreenUpdate&lt;/code&gt;会被调用60次，我们可以在里面做视图的更新操作。不过要注意的是，更新操作耗费时间不能超过1/60s，否则会掉帧。如果不想调用太频繁，可以设置&lt;code class=&quot;highlighter-rouge&quot;&gt;frameInterval&lt;/code&gt;的值，比如每秒只调用30次，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;frameInterval = 30&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有些读者可能会想到另一个相似的工具&lt;code class=&quot;highlighter-rouge&quot;&gt;NSTimer&lt;/code&gt;，不过它们还是有很大区别的，区别如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CADisplayLink是和屏幕刷新频率一致的，而NSTimer则不然，只是提供一个循环调用的功能，遇到NSRunLoop阻塞时还会延迟&lt;/li&gt;
  &lt;li&gt;NSTimer主要体现在控制循环次数上，而CADisplayLink则主要强调与屏幕刷新相关&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，对与实时性要求高的地方，使用CADisplayLink比较适合，比如我们要实现的动画。&lt;/p&gt;

&lt;h4 id=&quot;uiviewanimation&quot;&gt;UIViewAnimation&lt;/h4&gt;

&lt;p&gt;相信大家平时也使用过UIView的animation方法做过一些简单的动画，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIView animateWithDuration:_animationDuration + 0.5
                          delay:0.0
         usingSpringWithDamping:0.15
          initialSpringVelocity:1.40
                        options:0
                     animations:^{
                         ...
                     } completion:^(BOOL finished) {
                         ...
                     }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;做弹簧动画，参数和我们上文讲到的&lt;strong&gt;CASpringAnimation&lt;/strong&gt;有点相似。&lt;/p&gt;

&lt;h4 id=&quot;calayer&quot;&gt;CALayer&lt;/h4&gt;

&lt;p&gt;至于CALayer，由于上一篇文章介绍过，不赘述。但我们这里要介绍的，确切说应该是包含在UIView&lt;strong&gt;图层树&lt;/strong&gt;中的Layer。关于图层树，在我的&lt;a href=&quot;&quot;&gt;另一篇文章&lt;/a&gt;有介绍过。这里再简单介绍一下，大概就是UIView运行时在系统内部的Layer图层树分为三种，分别为模型层、展示层和渲染层，模型层就是持有view显示属性的view.layer；而展示层则是在动画执行时实时反映当前图层状态，为view.layer.presentationLayer；渲染层是私有的，用于将模型层异步渲染成为表示层。而WYChart中用得最多的莫过于展示层了，比如我们想获得动画执行时的view的位置，如果简单的通过view.frame.origin或者view.layer.position，那么获取到的结果并不是我们想要的，只能通过展示层view.layer.presentation.position才能获得临时位置，这一点在下文比较重要⚠️⚠️。上文提到的模式，确切的说应该是&lt;strong&gt;CADisplayLink+UIViewAnimation+presentationLayer的动画模式&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;上面介绍了这么多，其实都是为我们接下来要介绍的模式，&lt;strong&gt;CADisplayLink+UIViewAnimation+CALayer的动画模式&lt;/strong&gt;，所服务的。&lt;/p&gt;

&lt;p&gt;上文提到，我们要实现的线型图弹簧效果如下，但是用CASpringAnimation效果却相去甚远。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/LineAnimation_Spring.gif&quot; alt=&quot;Animation_Drawing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;确保你对上面概念了解清楚。
这时候我们就可以结合上面提到的这种模式来实现。&lt;/p&gt;

&lt;p&gt;手动实现一个线型图的弹簧动画，需要以下几个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取一系列和屏幕刷新频率相近的&lt;strong&gt;弹簧参数&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;根据弹簧参数构建一系列的贝塞尔曲线&lt;/li&gt;
  &lt;li&gt;在CADisplayLink每一帧刷新时刷新线型图曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要获取一系列和屏幕刷新频率相近的&lt;strong&gt;弹簧参数&lt;/strong&gt;，有两种方式，一种是自己模拟，也就是通过某个函数，类似的比如电波，但是经过一番搜索和对比，这个途径并不直观，有兴趣的童鞋可以自己探索一番；另一种方式，就是就近取材，UIViewAnimation+presentationLayer.position。&lt;/p&gt;

&lt;p&gt;做法是，1.定义N个透明的view，让它们做springAnimation&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[UIView animateWithDuration:_animationDuration + 0.5
                          delay:0.0
         usingSpringWithDamping:0.15
          initialSpringVelocity:1.40
                        options:0//UIViewAnimationOptionCurveEaseOut
                     animations:^{
                         [_animationControlPoints enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL * _Nonnull stop) {
                         	// 遍历所有模拟点视图，做动画
                             view.center = CGPointMake(view.center.x, ((WYLineChartPoint *)_parentView.points[idx]).y);
                         }];
                     } completion:^(BOOL finished) {
                         if (finished) {
                             _displayLink.paused = true;
                             self.userInteractionEnabled = true;
                         }
                     }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.开启CADisplayLink，在执行函数中通过view.layer.presentationLayer.position.x取得view与原点的偏离值
3.然后对所有给出的数据点的y值与偏离值做运算，得出新的y值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[_parentView.points enumerateObjectsUsingBlock:^(WYLineChartPoint *point, NSUInteger idx, BOOL * _Nonnull stop) {
    UIView *view = _animationControlPoints[idx];
    point.x = [view wy_centerForPresentationLayer:true].x;// 通过presentationLayer.position获得实时位置
    point.y = [view wy_centerForPresentationLayer:true].y;// 通过presentationLayer.position获得实时位置
}];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.重新构建贝塞尔曲线应用到线型图上，并完成一帧的刷新&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIBezierPath *linePath = [self currentLinePathForWave];
_lineShapeLayer.path = linePath.CGPath;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这便是我们的弹簧动画手动实现过程  🍻🍻&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;本文我们从CABasicAnimation及其相关类介绍开始，大致讲述了CoreAniamtion的动画类型及简单用法，接着介绍了WYChart中线型图的动画类型及部分简单实现方式，最后介绍了最重要的&lt;strong&gt;CADisplayLink+UIViewAnimation+CALayer的动画模式&lt;/strong&gt;。本文介绍到的内容，应该是每个iOS开发者都要了解的，因为很多UI层的内容都和它们息息相关。例如CADisplayLink+presentationLayer的模式，还可以结合UIDynamic做出很多接近现实的逼真的动画。总而言之，个人认为本文的内容还是比较有价值的，对于我自己，作为一个笔记，可以时常温习，对于新手开发者，又是一个提高的教程，希望它可以帮到你，谢谢你的阅读。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;相关文章&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://objccn.io/issue-12-0/&quot;&gt;Objc关于动画的介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore&quot;&gt;官方对QuartzCore的介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514&quot;&gt;官方的Animation指导&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zsisme.gitbooks.io/ios-/content/index.html&quot;&gt;GitBook上一本关于动画的书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Oct 2016 00:46:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/16/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E5%9B%9B-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/16/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E5%9B%9B-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        
        <category>WYChart</category>
        
        <category>开源</category>
        
        <category>动画</category>
        
        
      </item>
    
      <item>
        <title>WYChart介绍系列（三）线型图绘制</title>
        <description>&lt;p&gt;绘制是整个线型图实现的基础，如何绘制一个线型图？&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;中，我采用的是CAShapeLayer+UIBezierPath的组合，在这之前考虑过采用CoreGraphic做绘制，但是由于CALayer有CABasicAnimation一系列的动画支持，而且CoreAnimation框架都是Objective-C封装，相比CoreGraphic的C语言风格，更方便使用，所以最终还是采用CAShapeLayer+UIBezierPath的组合。此外，渐变前景的绘制用到CALayer的子类CAGradientLayer。&lt;/p&gt;

&lt;p&gt;线图中绘制的内容很多，但是总体并不复杂，&lt;strong&gt;主要&lt;/strong&gt;还是在以下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CALayer及CAShapeLayer的使用&lt;/li&gt;
  &lt;li&gt;UIBezierPath的使用&lt;/li&gt;
  &lt;li&gt;绘制平滑的曲线及其涉及的计算&lt;/li&gt;
  &lt;li&gt;CAGradientLayer绘制渐变层&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，本文也从上面四点介绍WYChart线型图的实现。&lt;/p&gt;

&lt;h3 id=&quot;calayercashapelayer&quot;&gt;CALayer及CAShapeLayer的使用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore/calayer&quot;&gt;官方文档&lt;/a&gt;对CALayer的介绍时这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The CALayer class manages image-based content and allows you to perform animations on that content. Layers are often used to provide the backing store for views but can also be used without a view to display content. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单地说就是CALayer类族管理与图像有关的内容并可以让你在上面做动画；Layer是View的基础，而且可以在View之外自己展示内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://objccn.io/issue-12-4/&quot;&gt;objc.io&lt;/a&gt;对CALayer是这样介绍的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。在 iOS 中也有一些单独的 layer，比如 AVCaptureVideoPreviewLayer 和 CAShapeLayer，它们不需要附加到 view 上就可以在屏幕上显示内容。两种情况下其实都是 layer 在起决定作用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可知layer是很重要的，如果对CALayer还不是很了解的话，可以从以上链接内容了解一下。&lt;/p&gt;

&lt;p&gt;CAShapeLayer是CALayer的一个子类，主要是渲染绘制在上面的贝塞尔线集合的形状。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore/cashapelayer&quot;&gt;官方文档&lt;/a&gt;对CAShapeLayer的介绍是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The CAShapeLayer class draws a cubic Bezier spline in its coordinate space. The shape is composited between the layer's contents and its first sublayer.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结合上面所述，我们知道可以在CAShapeLayer上绘制线型图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何使用CAShapeLayer ？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CAShapeLayer使用简单，只要初始化并添加到view.layer上就可以绘制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	CAShapeLayer *layer = [CAShapeLayer layer];
	...
	layer.path = path;
	//strokeColor, fillColor..的属性设置
	...
	[view.layer addSublayer:layer];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CAShapeLayer的主要属性有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;path : UIBezierPath // 决定Layer绘制形状的属性&lt;/li&gt;
  &lt;li&gt;strokeColor : UIColor // 决定线条的颜色&lt;/li&gt;
  &lt;li&gt;fillColor : UIColor // 决定被线条包围的封闭区域的填充颜色&lt;/li&gt;
  &lt;li&gt;lineWidth : CGFloat // 线条的宽度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外还有其它的，如用于绘制虚线的属性，都可以对绘制形状进行定制。&lt;/p&gt;

&lt;h3 id=&quot;uibezierpath&quot;&gt;UIBezierPath的使用&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，是对贝塞尔曲线的理解，他是一个怎样的东西？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A&quot;&gt;维基百科的介绍&lt;/a&gt;(需要翻墙)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于曲线的历史就不做介绍了，贝塞尔曲线最初用于汽车流体结构的设计。其原理就是通过所给出的点，以及&lt;strong&gt;相关方程&lt;/strong&gt;，根据&lt;strong&gt;时刻t&lt;/strong&gt;在某个[0,x]区间内计算出的所有&lt;strong&gt;点连成的直线／曲线&lt;/strong&gt;，称为贝塞尔曲线。&lt;/p&gt;

&lt;p&gt;贝塞尔曲线可分为一次曲线、二次曲线和高阶曲线，二相关方程表示如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一次曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/one_time_bezier.png&quot; alt=&quot;one_time_bezier&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;二次曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/two_times_bezier.png&quot; alt=&quot;one_time_bezier&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高阶曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/high_bezier.png&quot; alt=&quot;one_time_bezier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同曲线的绘制过程如下，注意方程计算出的&lt;strong&gt;点&lt;/strong&gt;的移动路径，即为曲线：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一次曲线，其实就是直线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/one_time_bezier.gif&quot; alt=&quot;one_time_bezier&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;二次曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/two_times_bezier.gif&quot; alt=&quot;one_time_bezier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如二次贝塞尔曲线，其实方程中的P1就是UIBezierPath中用到的&lt;strong&gt;控制点&lt;/strong&gt;（controlPoint)；以此类推，可知一次曲线没有控制点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，是UIKit中的UIBezierPath的使用方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/uikit/uibezierpath&quot;&gt;官方文档&lt;/a&gt;对UIBezierPath的介绍是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The UIBezierPath class lets you define a path consisting of straight and curved line segments and render that path in your custom views. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就是，UIBezierPath可以让你在自定义view上面绘制直线和曲线段。&lt;/p&gt;

&lt;p&gt;其实有了上面对于贝塞尔曲线的介绍，使用&lt;strong&gt;UIBezierPath&lt;/strong&gt;进行绘制应该比较简单了。&lt;/p&gt;

&lt;p&gt;UIBezierPath提供的方法有两种，一种是构造好的类方法，另一种是手动构造的，也是我们主要介绍的。&lt;/p&gt;

&lt;p&gt;构造好的类方法用于创建矩形、椭圆形、圆形、弧线等，方法如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (instancetype)bezierPathWithRect:(CGRect)rect; //矩形
+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect; //椭圆
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // 圆角矩形
+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; //弧形
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;手动构造的方法有以下几种：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)moveToPoint:(CGPoint)point; // 从某个点开始绘制
- (void)addLineToPoint:(CGPoint)point; // 从当前点添加直线到某个点
- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; // 从当前点P0，添加三次曲线到某个点P3，这个在上面的贝塞尔曲线介绍有提到
- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; // 从当前点P0，添加二次曲线到某个点P2，控制点为P1，这个在上面的贝塞尔曲线介绍有提到
- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0); //添加弧
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假如我们要绘制一段二次贝塞尔曲线，可以这样画：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:p0];
[path addQuadCurveToPoint:p2 controlPoint:p1];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上为贝塞尔曲线的介绍和UIBezierPath的用法。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;绘制平滑的曲线及其涉及的计算&lt;/h3&gt;

&lt;p&gt;如&lt;a href=&quot;&quot;&gt;上一篇文章&lt;/a&gt;所介绍的，WYChart中线型图类型有直线、波浪型曲线、尖峰型曲线等几种，关于直线，如上文介绍的，我们可以直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addLineToPoint:(CGPoint)point&lt;/code&gt;便可以绘制，这里我们主要介绍平滑的波浪型曲线的绘制，至于尖峰型曲线，如果你了解了波浪形曲线的画法，相信就很简单了。&lt;/p&gt;

&lt;p&gt;确保你记住上文中提到的&lt;strong&gt;贝塞尔曲线的概念&lt;/strong&gt;后，请看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/Draw_Curve.jpg&quot; alt=&quot;Draw_Curve&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设p1，p2，p3是给出的数据中连续三个点，绘制一段平滑的贝塞尔曲线，需要满足以下四种条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;某个点前后的点的值都比该点大，那么该点处于这段曲线的最底部&lt;/li&gt;
  &lt;li&gt;某个点前后的点的值都比该点小，那么该点处于这段曲线的最高处&lt;/li&gt;
  &lt;li&gt;某个点前后的点相比该点有一大一小，那么该点处于平缓的过渡段&lt;/li&gt;
  &lt;li&gt;每个点所在的曲线斜率为0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由上述最后一个条件，结合贝塞尔曲线原理（在本例中皆采用二次贝塞尔曲线，也就是只有一个控制点），在上面所给图中，p1和p2，或p2和p3之间若只有一个控制点，那么必定有一个点的斜率不为0，也就是造成曲线不平滑。那么，就只能分成两段进行绘制，如图中的p1和p2之间的曲线，我们取连线的中点m1为过渡点，分别绘制p1-m1，m1-p2的二次贝塞尔曲线；在两段曲线中再分别取控制点c1和c2，各个点满足以下关系：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m1(x,y) = ((p1(x)+p2(x))/2, (p1(y)+p2(y))/2)
c1(x,y) = ((p1(x)+m1(x))/2, p1(y))
c2(x,y) = ((m1(x)+p2(x))/2, p2(y))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于控制点的y值，分别取和p1以及p2相同，使得两点的线段斜率为0。p2-p3之间的曲线以此类推，也就是先取中点，再取控制点，最后绘制两段曲线，任意两点间需要绘制两段曲线。&lt;/p&gt;

&lt;p&gt;p1-p2曲线绘制代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIBezierPath *path = [UIBezierPath path];
[path moveToPoint:p1];
[path addQuadCurveToPoint:m1 controlPoint:c1];
[path addQuadCurveToPoint:p2 controlPoint:c2];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;绘制完毕 🍻🍻&lt;/p&gt;

&lt;p&gt;至于线型图另一种类型，尖峰曲线，不是平滑曲线，任何两点间都是一段向下凹的曲线，具体做法读者自行拓展，或者看WYChart源码。&lt;/p&gt;

&lt;h3 id=&quot;cagradientlayer&quot;&gt;CAGradientLayer绘制渐变层&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore/cagradientlayer&quot;&gt;官方文档&lt;/a&gt; 对CAGradientLayer的介绍是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The CAGradientLayer class draws a color gradient over its background color, filling the shape of the layer (including rounded corners)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;顾名思义，CAGradientLayer就是绘制渐变图层。可以生成两种或更多的颜色渐变，其使用了硬件加速渲染。&lt;/p&gt;

&lt;p&gt;使用方法是赋予一个colors数组和一个locations数组，前者表明渐变颜色，后者表明渐变颜色的位置&lt;/p&gt;

&lt;p&gt;在iOS绘制渐变图层还可以使用CoreGraphic的CGGradient，其比CAGradientLayer多出了径向渐变的画法，CAGradientLayer只支持轴向渐变。
另外，使用CoreImage框架也可以绘制渐变图层，这个有兴趣的自己探索下。&lt;/p&gt;

&lt;p&gt;在WYChart中，我们要实现的线型图渐变效果是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-13-WYChart-S/Line_Gradient.png&quot; alt=&quot;gradient&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以让线型图更加美观。&lt;/p&gt;

&lt;p&gt;绘制思路是这样的，在绘制好的渐变层上面加一个“面具”，以呈现曲线的轮廓。&lt;/p&gt;

&lt;p&gt;这个“面具”就是layer的mask属性，也是layer类型，由于需要具体的形状，我们定义一个和曲线轮廓一样的CAShapeLayer就可以了。&lt;/p&gt;

&lt;p&gt;“面具”mask就是在一个图层上加上一个有形状的图层，让原来的图层呈现出某个轮廓的边框。&lt;/p&gt;

&lt;p&gt;代码实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAShapeLayer *maskLayer = [CAShapeLayer layer];
...
UIBezierPath  *gradientPath = [UIBezierPath bezierPathWithCGPath:linePath.CGPath];
//构建与曲线相同的轮廓，做法和贝塞尔曲线绘制相同
...
maskLayer.path = gradientPath;
CAGradientLayer *gradientLayer = [CAGradientLayer layer];
gradientLayer.mask = maskLayer;
gradientLayer.colors = cgColors;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，gradientLayer.colors属性要求每个元素是CGColor类型的，故我们需要对UIColor做类型转换：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *cgColors = [NSMutableArray arrayWithCapacity:gradientColors.count];
    [gradientColors enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        CGColorRef cgColor;
        if ([obj isKindOfClass:[UIColor class]]) {
            cgColor = ((UIColor *)obj).CGColor;
        } else {
            cgColor = (__bridge CGColorRef)(obj);
        }
        [cgColors addObject:(__bridge id)cgColor];
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样子才能绘制出预想的效果。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;至此，我们的线型图绘制过程就完成了，我们大概通过下列几个重要过程绘制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CALayer及CAShapeLayer的使用&lt;/li&gt;
  &lt;li&gt;UIBezierPath的使用&lt;/li&gt;
  &lt;li&gt;绘制平滑的曲线及其涉及的计算&lt;/li&gt;
  &lt;li&gt;CAGradientLayer绘制渐变层&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将一个看似难的效果，分解成多个不同的技术点，逐个实现，便可破之。&lt;/p&gt;

&lt;p&gt;如果你对上述介绍还不是很清晰，结合源码进行阅读吧，戳👉&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下一篇我将继续介绍WYChart的线型图动画的实现。&lt;/p&gt;
</description>
        <pubDate>Sat, 15 Oct 2016 01:20:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/15/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%B8%89-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E7%BB%98%E5%88%B6/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/15/WYChart-%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%B8%89-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E7%BB%98%E5%88%B6/</guid>
        
        <category>WYChart</category>
        
        <category>开源</category>
        
        <category>动画</category>
        
        
      </item>
    
      <item>
        <title>WYChart介绍系列（二）线型图的框架概览及设计思路</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;零&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;一开始有做&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt;的想法，是公司的项目需要，在做了一段时间之后，刚好手头工作不多，于是萌生一个念头，试着自己写一个图表库，于是，WYChart便开始了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt; 里面包含了不少的技术点，动画的，绘制的，交互的，之所以在这之前没有做自己的图表库，原因之一是上文提到的公司项目需要才想到，另外一个很重要的原因是，没有相关方面的技术积累，也就是对动画，绘制，交互的一个全面的了解。恰巧在这之前，我看了《iOS Core Animation Tutorial》这本书以及一些优秀的开源库，动画库的源码，例如&lt;a href=&quot;https://github.com/Boris-Em/BEMSimpleLineGraph&quot;&gt;&lt;strong&gt;BEMSimpleLineGraph&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;https://github.com/anaglik/ANDLineChartView&quot;&gt;&lt;strong&gt;ANDLineChartView&lt;/strong&gt;&lt;/a&gt; 等，因此也对动画和绘制以及交互又了一个整体上的了解，进而全面的考虑各种实现方式的优缺点，以及采用更多的动画效果，交互方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt; 中，第一个做的是线型图，根据自己的判断，一个线型图，既要考虑内容的丰富、也要考虑用户的使用方便，又要考虑后续开发的可扩展性，难度不小，于是决定分而治之，逐个击破。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;壹&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;为了用户使用方便，降低学习成本，整个图库采用Cocoa典型的delegate/datasource模式，也就是UITableView/UICollectionView的模式，并结合属性设置，让图形的定制性更好。&lt;/p&gt;

&lt;p&gt;例如，以下两个代理方法(required)，可以自己定制X轴和Y轴的标签数目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- (NSInteger)numberOfLabelOnXAxisInLineChartView:(WYLineChartView *)chartView;
	- (NSInteger)numberOfLabelOnYAxisInLineChartView:(WYLineChartView *)chartView;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有如，以下两个选择性（optional）代理方法，可以自己定制水平和垂直方向参考线的数目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- (NSInteger)numberOfReferenceLineVerticalInLineChartView:(WYLineChartView *)chartView;
	- (NSInteger)numberOfReferenceLineHorizontalInLineChartView:(WYLineChartView *)chartView;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而在属性定制方面，有如下：&lt;/p&gt;

&lt;p&gt;设置可滑动：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scrollable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//横向滑动
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置可缩放：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pinchable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于动画的类型和时间：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WYLineChartAnimationStyle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animationStyle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animationDuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等等这些，对图形做多方面的定制。&lt;/p&gt;

&lt;p&gt;从分而治之的思想出发，把一个功能丰富的线型图分解为多个部件，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-12-WYChart-Line-Architecture/Total_Architecture.jpg&quot; alt=&quot;Total_Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始把线型图分为前景图和背景图。&lt;/p&gt;

&lt;p&gt;背景图相对简单，包含了背景，X轴图层，Y轴图层。&lt;/p&gt;

&lt;p&gt;前景图是最重要的，也是绘制难度最高的，并且动画最多的。&lt;/p&gt;

&lt;p&gt;其中包含水平、垂直、触碰点等参考线的图层；&lt;/p&gt;

&lt;p&gt;还包含最为核心的曲线图层。曲线图层又可以分为点、线以及渐变前景的绘制。&lt;/p&gt;

&lt;p&gt;而点的形状，可以分为三角形、正方形、圆形、五角星形，又可以分为空心与非空心，一共有八种形状。&lt;/p&gt;

&lt;p&gt;也就是代码中对应以下的几种类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	typedef NS_ENUM(NSUInteger, WYLineChartJunctionShapeStyle) {

		kWYLineChartJunctionShapeNone,
		kWYLineChartJunctionShapeSolidCircle,
		kWYLineChartJunctionShapeHollowCircle,
		kWYLineChartJunctionShapeSolidSquare,
		kWYLineChartJunctionShapeHollowSquare,
		kWYLineChartJunctionShapeSolidRectangle,
		kWYLineChartJunctionShapeHollowRectangle,
		kWYLineChartJunctionShapeSolidStar,
		kWYLineChartJunctionShapeHollowStar
	};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;线的形状，可以分为折线、波浪状平滑曲线、尖峰状曲线，又可以分为实线和虚线。&lt;/p&gt;

&lt;p&gt;对应以下的类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	typedef NS_ENUM(NSUInteger, WYLineChartMainLineStyle) {

		kWYLineChartMainStraightLine,
		kWYLineChartMainBezierWaveLine,
		kWYLineChartMainBezierTaperLine,
		kWYLineChartMainNoneLine
	};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上是关于&lt;strong&gt;图形层级结构&lt;/strong&gt;以及&lt;strong&gt;绘制&lt;/strong&gt;的分解情况。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;贰&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;此外&lt;/strong&gt;，&lt;strong&gt;动画展示&lt;/strong&gt;也是线型图的一个重点，如果没有动画，那么再好的绘制也少了一点生机，这一方面也是国内大多数app比较缺乏的。
线型图的动画主要是线条的动画，线条动画的分类如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-12-WYChart-Line-Architecture/Animation_Architecture.jpg&quot; alt=&quot;Animation_Architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，动画一共可以分为5种，为透明度动画、线条宽带动画、绘制动画、上升动画以及弹簧动画。&lt;/p&gt;

&lt;p&gt;对应代码中的类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	typedef NS_ENUM(NSUInteger, WYLineChartAnimationStyle) {

		kWYLineChartAnimationDrawing,
		kWYLineChartAnimationAlpha,
		kWYLineChartAnimationWidth,
		kWYLineChartAnimationRise,
		kWYLineChartAnimationSpring,
		kWYLineChartNoneAnimation
	};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于动画的介绍及实现，后续的文章会做介绍，这里不多赘述。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;叁&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;，&lt;strong&gt;交互&lt;/strong&gt;是线型图的一个关键，让用户能够更好的互动。&lt;/p&gt;

&lt;p&gt;考虑到移动设备屏幕一般都比较小，当数据多的时候，数据点显示会过于拥挤，因此，使用可滑动的线图，展示更多的数据就比较重要了。&lt;/p&gt;

&lt;p&gt;线型图中支持可滑动与不可滑动两种，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollable&lt;/code&gt;属性进行设置。&lt;/p&gt;

&lt;p&gt;又考虑到线型图可能会展示同一类型的多种层级的数据，于是，如何进行更好的切换等级，显得比较重要，WYChart采用了&lt;strong&gt;捏合手势&lt;/strong&gt;对线图做等级切换，实际上是更改数据源并做刷新。&lt;/p&gt;

&lt;p&gt;由于给出的数据点有限，如果我们对两个数据点之间的某些数据感兴趣，那么如果获取呢？&lt;/p&gt;

&lt;p&gt;经过一番思考以及参考别人的做法，一个可滑动的点会比较直观地显示两点间的数据，加上辅助标签和线，让点更佳直观；通过长按图形，进而滑动数据点来查看不同区间的数据值，交互感更强。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;肆&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;有时候一个效果很炫的动画或者一个功能很强大的工具，开始看到的时候会让我们吃惊，感觉难度很高，不可企及；但是，当你对相关的技术点有了一定的了解，再对眼前的庞然大物进行分解（分而治之），再加以实践，你会觉得其实并没有想象中难。任何一个工具，任何一个工程，都是从一行一行代码逐渐实现出来的，所以，只要有心探索研究，没有不可能。&lt;/p&gt;

&lt;p&gt;总而言之，WYChart中的线型图，以分而治之的思想，从模式、绘制、动画、交互四方面入手，逐个击破完善，从而实现一个较为满意的线型图，这个过程是一个挑战，也是一个学习提高的过程，希望以上能对你有所帮助，不足的希望得到您的反馈建议。&lt;/p&gt;

&lt;p&gt;在下一篇我将继续介绍线型图绘制的实现。&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Oct 2016 19:31:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/12/WYChart%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%BA%8C-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E7%9A%84%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/12/WYChart%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%BA%8C-%E7%BA%BF%E5%9E%8B%E5%9B%BE%E7%9A%84%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</guid>
        
        <category>WYChart</category>
        
        <category>开源</category>
        
        <category>动画</category>
        
        
      </item>
    
      <item>
        <title>WYChart介绍系列（一）概览</title>
        <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/GeorgeWang03/WYChart&quot;&gt;WYChart&lt;/a&gt;&lt;/strong&gt; 是我个人的第一个开源项目，发布至今收到挺多的github星星，也收到来自很多热心童鞋的建议和bug反馈，再此谢谢各位的支持。🎁🎁🍻🍻&lt;/p&gt;

&lt;p&gt;随着发布时间的推移，&lt;strong&gt;WYChart&lt;/strong&gt; 受到的关注也越来越多，也让我越坚定要把它继续推进和完善的决心。不过，在开源社区，我认为，真正的贡献不仅仅局限于发布一套代码，然后就完事，一些好的关于开源代码介绍的博文也是必须的。通过开源代码结合博文介绍，最直观的是让读者更容易了解其中的技术细节和实现方式；其次，也是对自己最重要的一点，是通过写博文，我们可以重新回顾整个代码编写过程，从而起到“温故”的作用，并且在后续的开发中，即使时间再长，也可以翻出以前的博文看一看，便会一目了然。开源社区给了我的帮助是在不计其数，作为一个热衷开源的程序员，我也应该为开源社区作出自己的一份贡献。通过分享自己的代码和心得，让更多的人看到，并在交流中看到自己的缺点，从而不断地提高。所以，在接下来的时间，我会尽自己最大的努力，不断完善 &lt;strong&gt;WYChart&lt;/strong&gt;，并创建其它的开源库/例子，另外，将把 &lt;strong&gt;WYChart&lt;/strong&gt; 中涉及到的技术点，通过多篇博文进行介绍，也希望读者能给出您宝贵的意见和建议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WYChart在目前的版本中有线型图和扇形图，我将从下面目录分篇介绍：&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;线型图&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.oneinbest.com/2016/10/12/WYChart介绍系列-二-线型图的框架概览及设计思路&quot;&gt;框架概览／设计思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.oneinbest.com/2016/10/15/WYChart-介绍系列-三-线型图绘制&quot;&gt;绘制：线条的绘制思路&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;动画：实现方式（draw,spring…)&lt;/li&gt;
  &lt;li&gt;交互：触碰点实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;扇形图&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;框架概览／设计思路&lt;/li&gt;
  &lt;li&gt;绘制 normal,gear&lt;/li&gt;
  &lt;li&gt;动画（AllSpreading,Stretch,Scale…）&lt;/li&gt;
  &lt;li&gt;交互（Extract,Pull,rotate…)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;希望以上内容能帮到你，不足之处，希望能得到你的建议和帮助。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Oct 2016 00:46:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/12/WYChart%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%B8%80-%E6%A6%82%E8%A7%88/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/12/WYChart%E4%BB%8B%E7%BB%8D%E7%B3%BB%E5%88%97-%E4%B8%80-%E6%A6%82%E8%A7%88/</guid>
        
        <category>WYChart</category>
        
        <category>开源</category>
        
        <category>动画</category>
        
        
      </item>
    
      <item>
        <title>创建自己的 Github 开源库并发布到 Cocoapods 插件库</title>
        <description>&lt;p&gt;&lt;strong&gt;前记：本文用于记录开源库的创建过程备忘以及初学者参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开发者们平时在&lt;strong&gt;Github&lt;/strong&gt;查看各种功能的开源库时，是否想过开源库从何而来？开源库如何创建？使用&lt;strong&gt;Cocoapods&lt;/strong&gt;时的&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'someLibrary'&lt;/code&gt;从何而来？&lt;/p&gt;

&lt;p&gt;最近发布了个人第一个严格意义上的开源库&lt;a href=&quot;'https://github.com/GeorgeWang03/WYChart'&quot;&gt;&lt;strong&gt;WYChart&lt;/strong&gt;&lt;/a&gt;，便想着把这个过程记录下来，以便后来者参考。本文将主要从Cocoapods创建公开库来说明Github + Cocoapods开源库创建全过程。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods&quot;&gt;一、创建Cocoapods工程库&lt;/h2&gt;

&lt;h3 id=&quot;desktopiospods&quot;&gt;1. 在你存放开工程库的工程文件夹目录下（比如我的是~/Desktop/iOS/Pods)，执行下面命令：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pod lib create MyLibrary
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着会出现以下问题，即工程库为Objective-C还是Swift，&lt;code class=&quot;highlighter-rouge&quot;&gt;What language do you want to use?? [ Swift / ObjC ]&lt;/code&gt;，根据你的需要输入，比如输入&lt;code class=&quot;highlighter-rouge&quot;&gt;Objc&lt;/code&gt;，然后Enter；&lt;/p&gt;

&lt;p&gt;再接着是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Would you like to include a demo application with your library? [ Yes / No ]&lt;/code&gt;，也就是是否包含&lt;strong&gt;例子工程(demo)&lt;/strong&gt;，需要的话选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Yes&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;然后是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Which testing frameworks will you use? [ Specta / Kiwi / None ]&lt;/code&gt;，选择测试框架，不需要的话选&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;接着是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Would you like to do view based testing? [ Yes / No ]&lt;/code&gt;，是否要基于视图测试；&lt;/p&gt;

&lt;p&gt;最后是&lt;code class=&quot;highlighter-rouge&quot;&gt;What is your class prefix?&lt;/code&gt;输入工程的前缀，所有的文件都会加上这个前缀。&lt;/p&gt;

&lt;p&gt;成功之后会有以下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Ace! you're ready to go!
	We will start you off by opening your project in Xcode
	open 'WYAnimations/Example/WYAnimations.xcworkspace'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即工程库创建成功，🍺🍺🎆🎆🍻🍻&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;2. 工程库目录简介&lt;/h3&gt;

&lt;p&gt;工程库创建完之后，Xcode界面会弹出:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-10-Github_Cocoapods/Xcode_Template.png&quot; alt=&quot;XcodeTemplate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上往下可以看到主要的文件夹有&lt;strong&gt;Podspec Metadata&lt;/strong&gt;，&lt;strong&gt;Example for yourLibrary&lt;/strong&gt;，&lt;strong&gt;Development Pods - YourLibrary&lt;/strong&gt;。
	&lt;strong&gt;Podspec Metadata&lt;/strong&gt;中分别有&lt;strong&gt;.podspec&lt;/strong&gt;、&lt;strong&gt;README.md&lt;/strong&gt;和&lt;strong&gt;LICENSE&lt;/strong&gt;，&lt;strong&gt;.podspec&lt;/strong&gt;为工程库的信息，详情格式google，&lt;strong&gt;README.md&lt;/strong&gt;中可以对工程库做介绍，cocoapods会默认帮你生成一个介绍的模版:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post_img/2016-10-10-Github_Cocoapods/README_DEFAULT.png&quot; alt=&quot;README&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，&lt;strong&gt;README&lt;/strong&gt;文件中常见的小图标，如&lt;img src=&quot;https://img.shields.io/cocoapods/l/WYAnimations.svg?style=flat&quot; alt=&quot;icon&quot; /&gt; 等，可以在&lt;a href=&quot;http://shields.io/&quot;&gt;这里&lt;/a&gt;找到并定制。
	&lt;strong&gt;LICENSE&lt;/strong&gt;默认是&lt;strong&gt;MIT&lt;/strong&gt;，你可以根据需要自行选择如Apache或 &lt;a href=&quot;http://choosealicense.com/&quot;&gt;其它的&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example for yourLibrary&lt;/strong&gt;便是存放Demo例子的文件夹，如同平时创建Xcode工程时一样。
	&lt;strong&gt;Development Pods - YourLibrary&lt;/strong&gt;，可以看到里面有&lt;strong&gt;ReplaceMe.m&lt;/strong&gt;文件，顾名思义，就是用你的组件库内容替换它，也即是工程库文件的存放地。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;3. 开发&lt;/h3&gt;

&lt;p&gt;在了解并创建完上述的工程之后，就可以编写你的工程库以及demo例子，如果工程和例子已经写好，那么直接复制替换到文件夹中就可以进入下一步发包了。&lt;/p&gt;

&lt;h2 id=&quot;github&quot;&gt;二、加入版本控制并推到Github&lt;/h2&gt;

&lt;p&gt;在Github上创建一个工程库，并在刚刚创建的本地工程库目录中，执行下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init  //初始化git仓库
$ git add . //暂存所有修改
$ git commit -m &quot;first commit&quot;  //提交修改
$ git remote add origin git@github.com:YourUserName/	  YourRepository.git  //添加远程仓库
$ git push -u origin master  //把本地内容推到Github远程仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，你便可以随时将修改更新到Github仓库上。&lt;/p&gt;

&lt;h2 id=&quot;cocoapods-1&quot;&gt;三、把版本的工程库发布到Cocoapods公开库或私有库&lt;/h2&gt;

&lt;p&gt;备注：这里主要介绍公开库，私有库👉&lt;a href=&quot;https://guides.cocoapods.org/making/private-cocoapods&quot;&gt;点击这里&lt;/a&gt;，公开库英文原版介绍👉&lt;a href=&quot;https://guides.cocoapods.org/making/getting-setup-with-trunk&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;pod&quot;&gt;1.创建pod帐号&lt;/h3&gt;

&lt;p&gt;如果你已经创建过，可以跳过这一步。&lt;/p&gt;

&lt;p&gt;在终端输入(pod帐号不需要密码，只是一个token存放在你的机器上)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pod trunk register 你的邮箱 '你的用户名' --description='关于你的机器的描述'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建完，或者创建过之后，执行下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pod trunk me
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会出现如下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	- Name:     GeorgeWang  //用户名
  		- Email:    georgewang003@gmail.com  //邮箱
  		- Since:    September 18th, 08:44  //时间
  		- Pods:	// 创建过的开源库
		- WYChart
  		- Sessions:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.发布开源库&lt;/h3&gt;

&lt;p&gt;⚠️ 需要注意的是，cocoapods对发布的开源库要求没有任何错误或警告信息，而且要有证书（这一点由于我们在上面的创建中已经生成证书所以不用担心）。&lt;/p&gt;

&lt;p&gt;确定你的工程没有问题，以及版本正确之后，你需要在你的项目目录中创建一个&lt;strong&gt;git分支&lt;/strong&gt;，标注版本号，如&lt;code class=&quot;highlighter-rouge&quot;&gt;0.1.0&lt;/code&gt;，这样才会被cocoapods接受。&lt;/p&gt;

&lt;p&gt;最后，在工程库目录执行下述命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	pod trunk push [NAME.podspec]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果成功的话，工程库便发布到cocoapods上了。&lt;/p&gt;

&lt;p&gt;可以在其它工程里面的&lt;strong&gt;podfile&lt;/strong&gt;尝试加入&lt;code class=&quot;highlighter-rouge&quot;&gt;pod YourRepository&lt;/code&gt;，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;pod install&lt;/code&gt;，如果成功，即工程库发布成功。🍻🍻🎆🎆&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.发布开源库的新版本&lt;/h3&gt;

&lt;p&gt;经历上述流程，我们已经把最初版本发布到cocoapods了，如果后续开发时，有新的版本发布，那么就需要更新cocoapods版本。具体流程如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;更新Podspec文件中的版本号，并把修改好的文件提交到mater分支&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在你确认发布的代码版本上打标签，标签版本号和上一步修改的一致&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git tag *version* 
  git push origin --tags //推到github
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检测新版本是否通过pod验证&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pod spec lint *your_pod_name*.podspec 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果通过了，那么发布podspec文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pod trunk push *your_pod_name*.podspec
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，新版本发布完成 🍻🍻  &lt;a href=&quot;http://sebastiandobrincu.com/blog/how-to-update-your-cocoapods-library-version&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记：发布流程至此结束，如果你对开源库有兴趣，行动吧，并推广你的开源库，让更多人知道你！&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 01:13:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/10/10/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Github-%E5%BC%80%E6%BA%90%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0-Cocoapods-%E6%8F%92%E4%BB%B6%E5%BA%93/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/10/10/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Github-%E5%BC%80%E6%BA%90%E5%BA%93%E5%B9%B6%E5%8F%91%E5%B8%83%E5%88%B0-Cocoapods-%E6%8F%92%E4%BB%B6%E5%BA%93/</guid>
        
        <category>Github</category>
        
        <category>Cocoapods</category>
        
        <category>OpenSource</category>
        
        
      </item>
    
      <item>
        <title>Github 的 ssh 秘钥配置 以及登录问题</title>
        <description>&lt;p&gt;最近在github上部署项目的时候遇到一个问题，将项目拷贝下来之后，修改完再度push上去，却收到 &lt;strong&gt;Permission to user/repo denied to other-user&lt;/strong&gt; 的错误，在github help搜索之后，其给出的答案如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	This error means the key you are pushing with is attached to an account which does not have access to the repository.
	To fix this, the owner of the repository (user) needs to add your account (other-user) as a collaborator on the repository or to a team that has write access to the repository.  大概意思就是所给出的秘钥无权利访问这个项目。需要让项目所有者将other-user加入到项目组。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;先说下最终的解决办法，其实就是以前登录过的账户保留在系统的钥匙串中，所以当前的用户是other-user，自然无权利访问。办法就是在系统钥匙串设置中将以前的邮箱关于github的钥匙串删除，回到终端重新push，输入账户和用户名，便可以。&lt;/p&gt;

&lt;p&gt;下面是分界线
***&lt;/p&gt;

&lt;p&gt;解决这个问题的时候，更重要的是一开始的误打误撞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.最开始&lt;/strong&gt; 以为是git的config问题，于是修改username,useremail等，下面是关于git config的一些设置方法&lt;/p&gt;

&lt;p&gt;config文件路径(mac os下) ： ~/.gitconfig&lt;/p&gt;

&lt;p&gt;config的设置分为几个等级，global，project，子级默认用上级的设置。&lt;/p&gt;

&lt;p&gt;命令行的设置法&lt;/p&gt;

&lt;p&gt;git config [–global] user.name yourUsername
git config [–global] user.email yourUsername&lt;/p&gt;

&lt;p&gt;在项目根目录下执行时，不加–global选项，为设置项目git配置。&lt;/p&gt;

&lt;p&gt;config的作用是，设置分支开发时的作者信息，暂时了解这点，其他的后续再研究。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.随后&lt;/strong&gt; 在stackoverflow和githelp上搜索，说是公钥的问题，于是研究了一下ssh key的配置&lt;/p&gt;

&lt;p&gt;github用rsa非对称秘钥来进行https的加密，用于客户端与github服务器进行通信时的认证，也就是常见的 git@github.com:user/rep 远程仓库通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于ssh key的部署&lt;/strong&gt;，👉 &lt;a href=&quot;&amp;quot;https://help.github.com/categories/ssh/&amp;quot;&quot;&gt;官方教程&lt;/a&gt; 
大概的步骤是&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.查看系统已经存在的rsa秘钥对&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ ls -al ~/.ssh  如果出现id_dsa与id_dsa.pub类似的私钥公钥秘钥对的话，就证明以前配置过，当然在这里是介绍怎么配置，所以继续往下看
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.新建秘钥对并添加到ssh代理&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;  然后设置秘钥的名字

	Enter a file in which to save the key (/Users/you/.ssh/id_rsa):  一般自己命名为 **id_rsa_somename**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下去的问题验证有兴趣的可以到githelp看，这里不做详解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Enter passphrase (empty for no passphrase): [Type a passphrase]
	Enter same passphrase again: [Type passphrase again]  直接按enter也可以
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.把秘钥对添加到代理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先查看代理是否可用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ eval &quot;$(ssh-agent -s)&quot;  出现下面结果

	Agent pid 59566(或者其它id)  证明是有用的，然后

	$ ssh-add ~/.ssh/id_rsa  id_rsa应该是第2步时你秘钥的命名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.把秘钥添加到你的github&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复制秘钥信息到粘贴板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ pbcopy &amp;lt; ~/.ssh/id_rsa.pub  选择github个人的 **setting-SSH and GPG keys-New SSH key or Add SSH key**
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入一个秘钥名字，然后command+v粘贴秘钥内容，最后点击&lt;strong&gt;Add SSH key&lt;/strong&gt;确认。&lt;/p&gt;

&lt;p&gt;5.检测秘钥对是否能链接成功&lt;/p&gt;

&lt;p&gt;终端输入 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	ssh -T git@github.com  如果出现：

	Hi username! You've successfully authenticated, but GitHub does not provide shell access.  则验证成功，可以正常使用了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实如果没配置ssh key的话，提示的错误信息应该是 &lt;strong&gt;Permission to user/repo denied to (other-)user/other-repo&lt;/strong&gt; ，所以遇到这个问题时也可以借鉴一下。&lt;/p&gt;

&lt;p&gt;如果有其它问题，请到githelp寻求帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上&lt;/strong&gt; 两种就是一开始误打误撞去探究的结果，虽说没有解决问题，但是也学如何配置git的秘钥等内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总而言之&lt;/strong&gt;，github的账户切换时，要注意对配置信息和钥匙串的更换，否则会出现Permission … denied to … 的错误。&lt;/p&gt;

</description>
        <pubDate>Thu, 22 Sep 2016 23:22:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/09/22/Github-%E7%9A%84-ssh-%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/09/22/Github-%E7%9A%84-ssh-%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</guid>
        
        <category>Git</category>
        
        <category>ssh</category>
        
        
      </item>
    
      <item>
        <title>关于我的博客说明</title>
        <description>&lt;p&gt;这是我的新博客，基于gitpage和jekyll搭建。&lt;/p&gt;

&lt;p&gt;你可能会看到有些文章比我博客项目时间还早，这是因为很多文章是从以前的&lt;a href=&quot;&amp;quot;www.oneinbset.com&amp;quot;&quot;&gt;博客&lt;/a&gt;迁过来的，是以前写的，不舍得放弃，所以迁过来了。&lt;/p&gt;

&lt;p&gt;我比较喜欢折腾，从一开始在csdn写博客，发现不尽我意，又自己买了一个主机和域名，使用wp搭建一个博客，现在由于wp比较笨重，加上所购买的主机空间有限，果断抛弃之，使用更加轻量级的jekyll和空间无限的gitpage。&lt;/p&gt;

&lt;p&gt;最后，欢迎来到我的博客，我会尽我所能，把我觉得有意义有价值的事情记录下来，您的支持是我的动力，谢谢！🍻🍻&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 07:39:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2016/09/22/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2016/09/22/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/</guid>
        
        <category>博客说明</category>
        
        
      </item>
    
      <item>
        <title>iOS中的KVO机制剖析</title>
        <description>&lt;p&gt;KVO即 key value observing键值对观察，是objc中的一种机制。
KVO以KVC(key value coding)为基础，通过向对象的某个键值添加观察者，当对象键所对应的值发生变化时，通知观察者，执行相关的回调方法。&lt;/p&gt;

&lt;p&gt;以下描述分为KVO的使用，OBJC实现KVO机制的剖析，KVO的DIY，fb的KVO开源库介绍，四部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	KVO的操作回调是在同一个线程中进行的，和NOTIFICATION一样
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;kvo&quot;&gt;1. KVO的使用&lt;/h2&gt;
&lt;p&gt;objc中给对象键值添加观察者，通过：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[obj addObserver:forKeyPath:option:context:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回调函数： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;observeValueForKeyPath:ofObject:change:context:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除通知：(这是一定要的，不然会导致crash)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;removeObserver:forKeyPath:
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objckvo&quot;&gt;2. OBJC实现KVO机制的剖析&lt;/h2&gt;
&lt;p&gt;先贴上几个解析来源：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;a href=&quot;&amp;quot;https://github.com/ChenYilong/iOSInterviewQuestions&amp;quot;&quot;&gt;《招聘一个靠谱的iOS》面试题&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;a href=&quot;&amp;quot;https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html&amp;quot;&quot;&gt;https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;objc通过什么来实现对键值添加观察者并发送通知呢？&lt;/p&gt;

&lt;p&gt;objc基于runtime,以setter方法为入口，实现这一机制。
首先需要知道的是，objc的对象实例isa指针，内存布局，Class结构体表示类。&lt;/p&gt;

&lt;p&gt;当向对象添加键值观察者时，objc通过runtime动态生成对象所属的类的子类，重写setter，并将对象的isa指针指向新类，在此过程中还重写了子类的class方法，向开发者隐藏新建子类 (也就是所谓的isa混写(isa-swizzling))。&lt;/p&gt;

&lt;p&gt;在新的类的setter中，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[super setObject:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在前后执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self willChangeValueForKey:]与[self didChangeValueForKey:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在后者执行时调用观察者的回调函数，所以在观察者dealloc时必须注销所设置的观察，否则会发送消息给dealloc对象，造成crash。&lt;/p&gt;

&lt;p&gt;##3. KVO的DIY
照例贴上手动实现KVO的方法链接：&lt;a href=&quot;&amp;quot;http://tech.glowing.com/cn/implement-kvo/&amp;quot;&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过上面的剖析，我们知道了KVO的实现原理&lt;/p&gt;

&lt;p&gt;如果要手动实现，那有两个过程必须实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.添加观察者接口及过程
2.键值改变时的通知过程实现
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;1.添加观察者接口及过程&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1 检查对象的类有没有相应setter方法，如果没有抛出异常；
	检查对象 isa 指向的类是不是一个有kPGKVOClassPrefix前缀的KVO类，如果不是需要创建新子类，并把isa指针指向新类，实现class方法

1.2 检查有没有KVO的setter方法，没有的话构建新类的setter方法

1.3 把观察者添加到观察者列表，使用***关联对象(objc_setAssociationObj)*** 绑定列表
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.键值改变时的通知过程实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.1 通过runtime动态执行父类也就是原来的类的setter方法

2.2 取出有关keyPath的观察者，并逐一调用回调函数block
  ##4.KVOController
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;👉 &lt;a ref=&quot;&quot;&gt;FaceBook的KVOController链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;KVOController是Facebook开源的一个KVO库，其可以聚合KVO操作，使用block执行观察操作，好处是可以不用自己去remove观察者，防止因为忘记remove造成crash，以下是其用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
// create KVO controller with observer
FBKVOController *KVOController = [FBKVOController controllerWithObserver:self];
self.KVOController = KVOController;

// observe clock date property
[self.KVOController observe:clock keyPath:@&quot;date&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(ClockView *clockView, Clock *clock, NSDictionary *change) {

  // update clock view with new value
  clockView.date = change[NSKeyValueChangeNewKey];
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;KVO&lt;/strong&gt; 是objc一项重要的特性和设计模式，也是GOF观察者模式的实现。开发中经常用于观察数据层(data)变化而对视图层(view)作出相应的改变，也是一种响应方式。由于其需要手动移动观察，否则会导致crash，所以使用时需要小心。Facebook的KVOController对objc的KVO进行封装，使用block模式，让开发者更省心。KVO在objc的底层实现是isa混编，生成子类并重写setter，然后通知观察中。手动实现KVO需要对类做是否KVO子类的判断，从而决定是否生成子类。总而言之，KVO是objc中一个比较重要的语言特性，使用好它，能为你带来不小的好处。&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Dec 2015 07:39:00 +0800</pubDate>
        <link>http://blog.oneinbest.com/2015/12/23/iOS%E4%B8%AD%E7%9A%84KVO%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2015/12/23/iOS%E4%B8%AD%E7%9A%84KVO%E6%9C%BA%E5%88%B6/</guid>
        
        <category>iOS</category>
        
        <category>KVO</category>
        
        
      </item>
    
      <item>
        <title>Objective-C 内存布局与对象生成</title>
        <description>&lt;p&gt;一直以来零碎的，连续的看过一些关于OC的内存布局及对象生成方案的文章，没对这方面的知识进行一个总结是心头大患 😔😔。&lt;/p&gt;

&lt;p&gt;接下来在这篇文章中，我将会介绍这方面的相关知识，只要内容有：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Object-C的类对象内存布局&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.Object-C对象如何生成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;废话不多说，我们开始吧！🎁🍺👇👇&lt;/p&gt;

&lt;h2 id=&quot;object-c&quot;&gt;一、Object-C的类对象内存布局&lt;/h2&gt;
&lt;p&gt; 	我们知道Object-C是又前端编译器clang转换为C++/C进而编译为机器码的；我们还知道Object-C中的类是单继承的；
	对于Object-C的一个类对象实例，或许你曾听说它有一个isa指针,这个isa有什么作用呢？
	通过下面一张图可能你会发现一些端倪 
	&lt;img src=&quot;/img/post_img/2015-11-17-objectivec/oc_memory_struct.jpg&quot; alt=&quot;oc_memory_struct&quot; /&gt;  	是的，类对象中除了isa指针还有superclass指针。
 isa顾名思义，is a class。。。来指明这是一个什么类的对象。
	根据上图，isa指针指向一个metaClass元类对象，这个对象是全局的，而且只有一个，metaClass存放类的静态变量和类方法，NSObject类对象的isa指向自身，而superClass指针则指向父类对象，NSObject类对象的superClass指针指向nil。&lt;/p&gt;

&lt;p&gt;当然，类对象和元类对象都拥有这两个指针，只是有所不同，从图中我们同样可以看到metaClass的isa指针指向的是NSObject元类对象，NSObject元类对象的isa指针则是指向自身；而其superClass则都指向父类的元类对象。&lt;/p&gt;

&lt;p&gt;当然，类中的信息不仅仅有isa和superClass指针，从runtime文件中我们可以找到Class的结构定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct objc_class {
Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中包括&lt;strong&gt;ivars&lt;/strong&gt;、&lt;strong&gt;methodLists&lt;/strong&gt;和&lt;strong&gt;protocol&lt;/strong&gt;等重要的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_ivar_list&lt;/code&gt;是类对象所持有的对象实例，最常见的就是平时声明&lt;strong&gt;@property&lt;/strong&gt;时，用下划线表示的_someProperty变量；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_method_list&lt;/code&gt;是存放所有实例方法的列表，调用实例对象的方法时，会在此列表中遍历寻找对应的函数入口；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_protocol_list&lt;/code&gt;存放该类所遵循的协议；&lt;/li&gt;
  &lt;li&gt;值得注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_cache&lt;/code&gt;，这是什么东西？其实这是objc对方法访问做优化的一个缓存，由于方法列表有可能很大，如果每次都在列表里面遍历，那效率自然就下降，特别是对于一些经常访问的方法，如tableView的&lt;code class=&quot;highlighter-rouge&quot;&gt;tableView:cellForRowsAtIndexPath:&lt;/code&gt;，高频率的访问带来的高频率遍历会耗费很多时间，而有了cache之后，在其中访问高频方法，速度会提升不少。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;细心的读者会主要到图中还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_object&lt;/code&gt;，这是一个什么东西呢？  这其实就是我们平常所声明的实例对象，其通过clang转换为以下结构：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  struct objc_object {
  	Class isa;
  };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其中只有一个isa类对象，就是指向对应的类对象内存地址，如上图所示。 既然提到oc的对象指针，那么我们自然会想到oc中的特殊指针id。 在runtime文件中我们同样可以看到id的定义：&lt;/p&gt;

    &lt;p&gt;typedef struct objc_object *id;
 这也就不难理解为什么id指针不用 * 而其他的要有 * 。
 所以我们平常所提到的&lt;strong&gt;isa&lt;/strong&gt;有三种含义，第一是&lt;strong&gt;实例对象的结构体中的isa&lt;/strong&gt;对象，第二是&lt;strong&gt;类中的isa&lt;/strong&gt;，其指向&lt;strong&gt;metaClass&lt;/strong&gt;类对象，第三是&lt;strong&gt;元类中的isa&lt;/strong&gt;,其指向NSObject元类对象。
  平常我们调用对象的变量，指针都通过第一类isa也就是实例对象中的isa去寻找相关的内容。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;object-c-1&quot;&gt;二、Object-C对象如何生成&lt;/h2&gt;
&lt;p&gt;有了上面的描述之后，相信大家对于objc中的类已经有一定的理解，甚至对其如何生成有一定的概念了。&lt;/p&gt;

&lt;p&gt;那么，一个Object-C对象在运行时如何被如何创建呢？&lt;/p&gt;

&lt;p&gt;可以这么说，当我们&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc/init&lt;/code&gt;一个对象时，runtime会创建oc独有的objc_object结构体对象，在创建结构体时会创建其中的isa，然后根据类的相关继承定义，由上往下，由父类往子类去创建相关的类对象，并把其中每个类对象的isa指向全局的meta元类对象。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc/init&lt;/code&gt;如何执行？&lt;/p&gt;

&lt;p&gt;一般我们在oc中创建一个对象的方式是&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Object alloc] init]&lt;/code&gt;,这相比起C++的new方法，多了一层函数调用。alloc会先在内存中申请对象的内存空间,init作为构造函数把相关的初始化值赋给对象，对于如NSString,NSDictionary等Foundation框架的对象，由于未能确定其数据长度，在alloc时会先指向一个placeHolder对象，当init的时候再申请相关的内存地址，其中的原因关乎内存字节对齐，由于这部分超出了本文的讨论范围，所以不讲，详情移步google。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;Objective-C基于C，其类对象在C语言层面是结构体，由clang转换而成，要探究Objective-C的内存布局，必须从C语言的结构体层面入手。经过分析，我们了解到其大体结构，主要的内容由isa、ivar、method_list等，并且由isa和superclass串联起整个布局。Objective-C对象生成时，实质是生成C的结构体实例，并对串联的isa、superclass指针做初始化，起到布局作用，在oc语言层面的alloc/init使得对象的内存分配和初始化分开，过程更加明确。总而言之，了解和掌握Objective-C的内存布局及对象的创建过程，有助于平时开发和调试，也是提升开发能力的一个要求。&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Nov 2015 17:04:18 +0800</pubDate>
        <link>http://blog.oneinbest.com/2015/11/17/Objective-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90/</link>
        <guid isPermaLink="true">http://blog.oneinbest.com/2015/11/17/Objective-C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%94%9F%E6%88%90/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>内存</category>
        
        
      </item>
    
  </channel>
</rss>
